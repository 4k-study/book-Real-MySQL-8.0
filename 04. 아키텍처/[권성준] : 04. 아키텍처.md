## 개요

- MySQL 엔진 → 사람의 머리 역할
- MySQL 스토리지 엔진 → 사람의 손발 역할

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/93aff415-de51-4f08-b416-4dcb9f47366e)

**MySQL 엔진**

- 커넥션 핸들러, SQL 파서 및 전처리기, 옵티마이저 중심으로 구성
- 표준 SQL 문법을 지원
- MySQL 서버에서 엔진은 하나만 존재

**스토리지 엔진**

- **실제 데이터를 디스크에 저장하고 읽어오는 역할** 담당
- MySQL 서버에서 스토리지 엔진은 여러 개 동시에 사용 가능

**핸들러 API**

- 데이터 I/O 작업이 있을 때 **엔진은 스토리지 엔진에 요청을 하는데 이를 핸들러 요청**이라 하고, 핸들러 API를 사용함
- 스토리지 엔진은 이 핸들러 API를 구현해야 함

### 4.1.2 MySQL 스레딩 구조

![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/5a029ccc-4ffc-4b95-805a-91a366fd4a19)

- MySQL 은 프로세스가 아닌 스레드 기반이고, 크게 포그라운드 스레드, 백그라운드 스레드로 구분

**포그라운드 스레드**

- 최소 MySQL 에 접속한 사용자 수 만큼 존재 → 사용자 스레드라고 불리는 이유
- 사용자가 요청한 쿼리 문장을 처리함
    - 사용자가 커넥션을 종료하면 담당 스레드는 스레드 캐시로 돌아감
    - 스레드 캐시에 설정된 수 이상이 있으면 스레드 캐시로 복귀하지 않고 종료함
- 데이터를 데이터 버퍼나 캐시로부터 가져옴. 없으면 디스크나 인덱스로부터 직접 가져옴
- MyISAM 은 포그라운드 스레드가 디스크 쓰기 작업까지 담당하지만 InnoDB는 버퍼나 캐시까지만 담당함

**백그라운드 스레드**

- 백그라운드 스레드로 처리하는 작업들
    - 인서트 버퍼 병합
    - 로그를 디스크에 기록
    - 버퍼의 데이터를 디스크에 기록
    - 데이터를 버퍼로 읽어 오는 스레드
        - 포그라운드도 담당하지만 백그라운드도 담당함
    - 잠금, 데드락 모니터링
- InnoDB는 쓰기 작업을 백그라운드 스레드가 담당하여 쓰기 작업을 버퍼링하여 일괄 처리할 수 있음
    - DML 쿼리로 데이터 변경 시 디스크 기록을 기다리지 않아도 됨

### 4.1.3 메모리 할당 및 사용 구조

![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/de030381-5bb2-4d20-a77d-c40a7abc4c58)

- 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분됨
- 스레드가 공유해서 사용하는지 여부에 따라 구분

**글로벌 메모리 영역**

- 구성
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼
- 사용자 스레드와 관계 없이 하나의 공간을 할당 받고 **모든 스레드에서 공유**됨
    - MySQL 서버 실행 시 운영체제로부터 할당 받음

**로컬 메모리 영역**

- **사용자 스레드가 쿼리 처리 시 사용**되는 영역
- 스레드 별로 독립적으로 할당되어 **공유되지 않음**
- 쿼리의 용도 별로 필요 시에만 할당되고 필요하지 않으면 할당되지 않을 수 있음
    - ex) 소트 버퍼, 조인 버퍼
- 구성
    - 정렬 버퍼
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델

- 스토리지 엔진, 검색어 파서, 인증 등을 플러그인을 통해 활용 가능함
- MySQL 쿼리 실행 과정
    - SQL 파서 → SQL 옵티마이저 → SQL 실행기 → 데이터 읽기/쓰기 → 디스크
        - 스토리지 엔진은 데이터 읽기/쓰기 단계만 담당함
- 플러그인 구조를 통해 사용자의 요구사항을 위한 플러그인을 쉽게 다운 받아 확장 가능함

### 4.1.5 컴포넌트

- MySQL 8.0 부터 플러그인 아키텍처의 단점을 보완하고자 등장
- 플러그인 아키텍처의 단점
    - 오직 MySQL 서버와 통신 가능하고, 플러그인끼리는 통신 불가능함
    - MySQL 서버의 변수, 함수를 직접 호출하기에 캡슐화되지 않음
    - 플러그인끼리의 상호 의존 관계를 설정할 수 없음 → 초기화 어려움

### 4.1.6 쿼리 실행 구조

쿼리 파서 → 전처리기 → 옵티마이저 → 쿼리 실행기 → 스토리지 엔진의 과정을 거침

**쿼리 파서**

- 사용자가 요청한 **쿼리 문장을 토큰으로 분리해 트리 구조로 만들어 냄**
- 쿼리의 기본 문법 오류를 발견하고 사용자에게 오류를 전달함

**전처리기**

- **파서 트리를 바탕으로 쿼리 구조의 문제를 확인**
- 테이블 명, 칼럼 명, 내장 함수 개체를 매핑하여 존재 여부와 접근 권한 등을 확인함

**옵티마이저**

- 쿼리 문장의 비용을 최적화함 → DBMS 의 두뇌 역할

**실행 엔진**

- 실행엔진은 회사로 치면 중간 관리자로 비유 가능
- 옵티마이저가 만든 게획대로 핸들러에게 요청하여 연결하는 역할을 함

**핸들러(스토리지 엔진)**

- 엔진과 디스크를 연결하는데 필요함. 이 핸들러를 구현한 것을 스토리지 엔진이라고 함.

### 4.1.8 쿼리 캐시

- SQL 실행 결과를 메모리에 저장하고 같은 쿼리가 요청되면 디스크를 읽지 않고 메모리에서 결과 반환 → 빠른 성능
- 테이블 데이터가 변경되면 관련된 쿼리 캐시를 전부 삭제해야 함
    - 동시 처리 성능 저하 및 버그의 원인이 됨
    - MySQL 8.0 부터는 제거됨

### 4.1.9 스레드 풀

- 엔터프라이즈 용은 스레드 풀을 지원하지만, 커뮤니티 용은 지원하지 않으므로 Percona Server 의 스레드 풀 내용을 알아봄
    - 커뮤니티 용에서 스레드 풀을 사용하려면 Percona Server 의 플러그인을 다운받으면 됨
- 스레드 풀의 목적은 **MySQL 서버가 설정된 스레드 처리에 집중하여 서버 리소스 낭비를 방지**하기 위함임
- 기본적으로 CPU 코어 수만큼 스레드 그룹 생성함
    - 코어 갯수와 맞추는 것이 CPU 프로세서 친화도가 높음
- 스레드 풀의 스레드가 전부 사용 중일 때 요청이 들어오면 `thread_pool_oversubscribe` 시스템 변수에 설정된 갯수만큼 추가로 더 받아들임
- 스레드 그룹의 스레드가 모두 사용 중일 경우 스레드 풀은 스레드 그룹에 스레드를 추가할지 기다릴지 판단해야 함
    - 타이머 스레드가 `thread_pool_stall_limit` 시스템 변수에 저장된 밀리초 안에 작업이 끝나지 않으면 스레드 그룹에 스레드를 추가함
    - 스레드 풀의 전체 스레드 수는 `thread_pool_max_threads` 시스템 변수 값을 넘지 못함
    - 스레드 수가 최대이고 전부 사용 중이면, `thread_pool_stall_limit` 시간동안 기다려야 함
- 선순위 큐와 후순위 큐를 이용하여 특정 트랜잭션이나 퀴리를 우선적으로 처리할 수 있음
    - 잠금 경합을 낮출 수 있음

### 4.1.10 트랜잭션 지원 메타데이터

- 기존 문제
    - MySQL 8.0 이전에는 테이블 구조, 스토어드 프로그램 등의 정보가 파일로 관리됨
        - 트랜잭션 아래에서 생성/변경이 일어나지 않기에 깨질 수 있음
- MySQL 8.0 부터 테이블 구조, 스토어드 프로그램, 시스템 관련 정보를 InnoDB 테이블에 저장함
- InnoDB 이외의 스토리지 엔진을 사용하는 테이블은 SDI 파일을 사용

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB 는 MySQL 의 스토리지 엔진 중 거의 유일하게 레코드 잠금을 제공함. 이를 통해 높은 동시성 처리가 가능하고 안정적임.

![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/ca27feb6-7a41-4e8e-ab81-133b9d319383)

### 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB 의 모든 테이블은 PK 를 기준으로 클러스터링 되어 저장됨
    - 세컨더리 인덱스는 PK 값을 논리적 주소로 가짐
- 실행계획에서 PK 는 상대적으로 비중이 높음
- MyISAM 은 PK 를 클러스터링하지 않음. 즉, PK 는 유니크한 세컨더리 인덱스임
    - 모든 인덱스는 ROWID 라는 물리적 주소를 가짐

### 4.2.2 외래 키 지원

- InnoDB 엔진만 지원하는 기능임
- 부모, 자식 테이블 모두에 인덱스 생성이 필요하고, 변경 시 데이터 체크 작업이 필요하므로 여러 테이블에 잠금이 전파됨.
    - 이로 인해 데드락 발생 가능
    - `foreign_key_checks` 시스템 변수 사용하면 외래 키 체크 작업을 일시적으로 멈출 수 있음

### 4.2.3 MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS 에서 일반적으로 제공함
    - 하나의 레코드를 여러 개의 버전으로 관리함
- **잠금을 사용하지 않는 일관적 읽기가 주된 목적**
    - InnoDB는 언두 로그를 활용해 구현
- 격리 레벨이 READ_COMMITED 일 때 update 과정
    - update 시 기존 값은 언두 로그에, 새로운 값은 버퍼 풀에 넣음
    - 커밋 전에 다른 트랜잭션이 작업 중인 레코드 조회 시 언두 로그 값을 반환
    - 롤백 시에 언두 로그 값을 버퍼 풀로 복구하고 언두 로그 삭제함
    - 커밋 시에 버퍼 풀 값을 디스크에 기록하고, 언두 로그를 필요로 하는 트랜잭션이 없을 때 언두 로그 삭제함
- 트랜잭션이 길어지면 관리해야하는 언두 로그가 많아질 수 있음
- 커밋이나 롤백 전에 작업 중인 레코드를 다른 트랜잭션에서 조회할 때의 결과는 트랜잭션 격리 레벨에 따라 달라짐

### 4.2.4 잠금 없는 일관된 읽기

- MVCC 를 활용하여 SERIALIZABLE 이 아닌 이상 SELECT 작업은 잠금 없이 실행됨
- 트랜잭션이 길어지면 언두 로그가 많아져서 MySQL 서버가 느려지는 문제가 발생할 수 있음
    - 가능한 한 짧게 커밋이나 롤백을 하는 것이 좋음

### 4.2.5 자동 데드락 감지

- InnoDB는 내부적으로 잠금 대기 목록을 그래프 형태로 관리함
- 데드락 감지 스레드가 주기적으로 잠금 대기 목록을 검사해 교착 상태의 트랜잭션 중 하나를 강제 종료함
    - 종료하는 기준은 트랜잭션의 언두 로그 양이 적은 순임. 언두 로그의 양이 적을수록 롤백으로 인한 MySQL 서버 부하가 적기 때문임.
- 데드락 감지 스레드는 잠금 목록 검사 시 잠금 테이블에 잠금을 거는데, 동시 처리가 많거나 트랜잭션이 가진 잠금 수가 많아지면 느려져서 서비스에 악영향을 미치게 됨.
    - `innodb_deadlock_detect` 를 OFF 하면 끌 수 있지만, 데드락 시 무한 대기하게 되므로 `innodb_lock_wait_timeout` 을 활용하여 대처하면 됨.

### 4.2.6 자동화된 장애 복구

- InnoDB 는 MySQL 서버 실행 시 완료되지 못한 트랜잭션, 디스크에 일부만 기록된 데이터 페이지 등에 대한 복구를 자동 실행함
- 만약 자동 복구으로 복구되지 않는 손상으로 인해 MySQL 서버가 종료된다면 `innodb_force_recovery` 시스템 변수를 설정하여 시작하면 됨

### 4.2.7 InnoDB 버퍼 풀

- **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간**
- 쓰기 작업을 지연하여 일괄 처리해주는 **버퍼 역할**

**버퍼 풀의 크기 설정**

- 가능하면 버퍼 풀 크기를 적절히 작게 설정한 후 필요 시마다 늘리는게 최적임
    - `innodb_buffer_pool_size` 시스템 변수로 설정 가능
- 내부적으로 128MB 청크 단위로 관리됨. 버퍼 풀 크기를 조절하는 단위임.

**버퍼 풀의 구조**

![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/f99402f9-6544-4be9-a19f-969e797c8a2a)

- 버퍼 풀을 페이지 크기의 조각으로 쪼개어 관리
    - 페이지 크기 조각 관리를 위해 LRU 리스트, 플러시 리스트, 프리 리스트 자료구조로 관리
        - 프리 리스트
            - 버퍼 풀에서 실제 데이터로 채워지지 않은 페이지들의 목록임. 실제 디스크에서 데이터 페이지를 읽을 때 사용함.
        - LRU 리스트
            - LRU + MRU 형태임. 디스크로부터 읽은 데이터를 최대한 오래 보관하여 디스크 접근을 최소화 하기 위함.
            - LRU → Old 서브리스트
            - MRU → New 서브리스트
        - 플러시 리스트
            - 디스크로 동기화되지 않은 데이터를 가진 페이지 목록을 관리함

**버퍼 풀과 리두로그**

- 버퍼 풀
    - 버퍼 풀은 디스크에서 읽은 후 변경되지 않은 클린 페이지와 변경된 더티 페이지를 가짐
        - 더티 페이지는 디스크에 동기화해야 함
- 리두 로그
    - 리두 로그는 1개 이상의 고정 크기 파일을 연결하여 순환 고리처럼 사용함
    - 데이터 변경이 계속되면 리두 로그의 로그 엔트리는 덮어씌워짐
    - 리두 로그에서 재사용 가능/불가능한 공간을 구분해야함
        - 재사용 불가능 공간 → 활성 리두 로그 영역
    - 리두 로그 파일이 계속 순환되어 사용되지만, 기록될 때마다 로그 포지션이 증가함. 이를 LSN 이라고 함.
    - 디스크와의 동기화 시 가장 최근 체크포인트의 LSN이 활성 리두 로그의 시작점임
    - 체크 포인트 에이지
        - 최근 체크포인트의 LSN 과 마지막 리두 로그 LSN 차이가 활성 리두 로그 영역의 크기임. 이를 체크 포인트 에이지라고 함.
    - 체크포인트 발생 시 체크포인트 LSN보다 작은 리두 로그에 연결된 더티 페이지를 디스크에 동기화함. 리두 로그도 함께 동기화함.

**버퍼 풀 플러시**

- InnoDB 는 아래 2가지 플러시를 백그라운드로 실행해 더티 페이지들을 디스크로 동기화함
    - 플러시 리스트 플러시
        - 버퍼 풀의 플러시 리스트를 동기화
    - LRU 리스트 플러시
        - 사용 빈도 낮은 데이터 페이지를 디스크로 동기화하고 버퍼 풀에서 제거함

**버퍼 풀 상태 백업 및 복구**

- 버퍼 풀에 데이터가 적재되어 있는 상태 → 워밍업 상태
    - 쿼리 성능이 10배 이상 차이 날 수 있음
- 5.5 버전에서는 강제 워밍업을 하고 실행했음. 5.6 이상 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입됨

### 4.2.8 Double Write Buffer

- 더티 페이지를 디스크로 동기화하다 일부만 기록되면 복구하기 까다로움. 이를 해결하고자 Double Write Buffer 사용함
- 더티 페이지를 디스크에 동기화하기 전에 시스템 데이블 스페이스의 Double Write 버퍼에 한번의 디스크 I/O 로 기록해놓음

### 4.2.9 언두 로그

- 트랜잭션과 격리 수준을 보장하기 위해 언두 로그를 통해 변경 이전 데이터를 보관
- 문제점
    - 트랜잭션이 길어질 경우 언두 로그가 쌓여 서비스 성능이 악화될 가능성 있음

### 4.2.10 체인지 버퍼

- INSERT, UPDATE 작업 시 인덱스도 변경해줘야 함. 인덱스 변경은 랜덤하게 디스크를 읽으므로 인덱스가 많다면 많은 리소스를 소모하게 됨.
    - 변경해야할 인덱스 페이지가 버퍼 풀에 있다면 바로 실행하지만, 없다면 체인지 버퍼에 저장해두고 사용자에게 바로 결과를 반환함
    - 유니크 인덱스는 체인지 버퍼 사용할 수 없음

### 4.2.11 리두 로그 및 로그 버퍼

- 리두 로그
    - 서버가 비정상적으로 종료될 시 데이터 파일에 기록되지 못한 데이터를 복구하게 해주는 안전장치임
- 로그 버퍼
    - 리두 로그 버퍼링에 사용되는 공간임. 리두 로그는 영속성을 위해 중요하지만 비용이 크므로 성능을 위해 버퍼링을 하는 것임.

### 4.2.12 어댑티브 해시 인덱스

- 사용자가 수동으로 생성하는 인덱스가 아님. InnoDB가 자주 요청되는 데이터에 대해 자동으로 생성하는 인덱스임.
- B-Tree 의 검색 시간을 줄여주기 위함
    - 자주 읽히는 데이터 페이지의 키 값을 사용해 해쉬 인덱스를 만듬. B-Tree 의 루프 노드, 브랜치 노드를 거치는 단계가 사라져서 빠름.
- 해쉬 인덱스는 인덱스 키 값과 데이터 페이지 주소의 쌍으로 관리됨
    - 인덱스 키 값은 인덱스 고유번호와 인덱스의 실제 키 값의 조합으로 생성됨
        - 어댑티브 해쉬 인덱스는 하나만 존재하기에 인덱스 고유번호를 통해 어떤 인덱스인지 구분해줘야 함
    - 데이터 페이지 주소는 버퍼 풀에 로딩된 페이지 주소를 의미함
        - 버퍼 풀에 올려진 데이터를 대상으로만 어댑티브 해시 인덱스가 관리함
- 도움이 되는 경우
    - 디스크 데이터가 버퍼 풀 크기와 비슷한 경우
    - 동등 조건 검색이 많은 경우
    - 쿼리가 일부 데이터에만 집중되는 경우
- 도움이 안되는 경우
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴)
    - 매우 큰 데이터를 폭넓게 읽는 경우

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

버전이 올라가면서 모든 면에서 InnoDB 가 앞서고 InnoDB 만 지원하지 않는 기능이 없음. InnoDB 를 사용하자.

## 4.4 MySQL 로그 파일

- 로그 파일을 사용하면 MySQL 의 상태나 부하 원인을 쉽게 파악할 수 있음

### 4.4.1 에러 로그 파일

- MySQL 설정 파일(my.cnf) 에서 `log_error` 파마리터로 정의된 경로에 생성

### 4.4.2 제너럴 쿼리 로그 파일

- `general_log_file` 파라미터로 정의된 경로에 생성
- `log_output` 파라미터로 파일로 저장할지 테이블로 저장할지 결정

### 4.4.3 슬로우 쿼리 로그

- `long_query_time` 시스템 변수로 설정한 시간 이상의 쿼리들이 모두 기록됨
- 쿼리가 정상적으로 실행되어야 슬로우 쿼리 로그에 기록됨

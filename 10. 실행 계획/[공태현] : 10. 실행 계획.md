## 통계 정보
- 옵티마이저는 통계 정보를 바탕으로 실행 계획을 수립하기 때문에 통계 정보는 굉장히 중요하다. 
- MySQL 5.7 버전보다 8.0 버전 이후로 들어가면서 통계 정보에 포함되는 정보가 더 다양해짐

### 테이블 및 인덱스 통계 정보
- 통계 정보는 예전에는 메모리에만 저장되어 서버 재시작 시 초기화 되었으나, 5.7 이후 버전부터 테이블로 관리되어 영구적으로 저장됨
	- 예전 버전에는 특정 상황이 발생했을 때 테이블 통계 정보가 자동으로 수집되었다.
	- 영구 통계 정보를 사용하면 굳이 자동으로 갱신시키지 않아도 되기 때문에 설정을 통해 바꿀 수 있음
	- 설정 값 변경을 통해 테이블마다 통계 정보를 영구히 저장할지, 메모리에 저장할지 변경할 수 있음
- 통계 정보를 수집할 때 얼마나 많은 양을 수집할지 설정 값을 통해 결정할 수 있다.

### 히스토그램
- 히스토그램은 테이블의 전체 레코드 수, 인덱스된 칼럼이 가지는 유니크한 값의 개수보다 더 구체적인 정보라고 보면 된다.
- 히스토그램을 통해 더 구체적인 레코드나 테이블의 상태를 알 수 있기 때문에 옵티마이저가 더 최적화된 쿼리를 실행할 수 있는 실행 계획을 수립할 확률이 높아진다.
- 인덱스 되지 않은 컬럼이 쿼리 조건에 쓰였을 때 더 유용하게 사용될듯 하다.
- 쿼리를 실행할 때, 조건절에 포함된 컬럼에 인덱스가 적용되어 있다면, 히스토그램 정보 대신 해당 인덱스에 대한 정보를 가지고 쿼리 실행 계획을 수립한다. (이게 더 정확하기 때문)
	- 이를 '인덱스 다이브'라고 한다.

## 실행계획 확인
 - 트리 기반, 테이블 기반으로 확인할 수 있음
 - 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있음

## 실행 계획 분석
### **id 컬럼**
 SELECT 쿼리를 구분하기 위한 용도의 컬럼이다. (SELECT문이 몇 개인지를 확인한다고 보면 된다.)
- SELECT와 JOIN이 연결되어 있더라도 같은 id를 갖는다.
- SELECT 내부에서 서브쿼리를 사용한다거나 UNION을 사용한다면 각각 다른 id를 갖는다.

### **select_type 컬럼**

<aside> 💡 SELECT 쿼리가 어떤 타입인지 나타내는 용도의 컬럼이다.

</aside>

- **SIMPLE**
    
    - UNION이나 서브쿼리를 사용하지 않은 **단순 SELECT 쿼리**의 경우 SIMPLE로 표시 (JOIN한 경우도 SIMPLE 타입으로 친다.)
    - 실행 계획 테이블에서 select_type이 SIMPLE인 쿼리는 반드시 하나만 존재한다.
- **PRIMARY**
    
    - UNION이나 서브쿼리를 가지는 쿼리 중에서 가장 바깥쪽에 위치한 쿼리
    - 최대 한 개만 존재
- **SUBQUERY**
    
    - FROM절 **이외에** 사용된 서브 쿼리에 표기한다.
    - FROM 절에 사용된 서브 쿼리는 **DERIVED** 로 표기된다.
- **DEPENDENT SUBQUERY**
    
    - FROM절 이외에 사용된 **서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우**에 해당 서브 쿼리에 표기된다.
- **DERIVED**
    
    - FROM절에 사용된 서브 쿼리로 SELECT 쿼리의 결과로 메모리나 디스크에 임시 테이블을 만드는 경우를 의미한다.
    - FROM 절에 서브쿼리 대신 조인을 사용하여 최적화하자
- **MATERIALIZED**
    
    - FROM 절이나 IN (subquery) 형태의 쿼리에 사용된 서브 쿼리를 최적화할 때 사용된다. 이 경우에 보통 서브 쿼리보다 외부 쿼리의 테이블을 먼저 읽어서 비효율적으로 실행되기 마련인데 이렇게 실행하지 않고 서브 쿼리의 내용을 임시테이블로 구체화한 후 외부 테이블과 조인하는 형태로 최적화된다. 이 때, 서브 쿼리가 먼저 구체화되었다는 것을 표기할 때 사용된다.
    - 뭔가 효율적으로 개선된 듯하지만 결국 임시테이블을 사용하므로 엄청 효율적이지는 않다.
- 쿼리 타입만 보고도 어떤 쿼리를 개선해야할지 감이 잡히기 때문에 잘 알아두는 것이 좋겠다.
    
- 기본적으로 `DEPENDENT` 는 외부 쿼리에 의존하므로 성능이 느리고 `임시 테이블`을 사용하는 것들도 디스크에 임시 테이블을 만들 위험이 있기에 제거 대상이다. (메모리에 임시 테이블은 그나마 좀 낫다.)
    
- `DERIVED` 도 최대한 JOIN으로 해결해야하기에 제거 대상이 된다.
    

### **table 컬럼**

- EXPLAIN 키워드로 실행 계획을 확인할 때, SELECT 쿼리로 분류하는게 아니라 테이블 단위로 분류해서 결과가 나온다.
- 어떤 테이블에 대한 정보인지를 나타낸다.
- table 컬럼에 `<>` 로 감싸져있는 경우를 볼 수 있는데 이 테이블은 **임시 테이블**을 의미한다.

### **partitions 컬럼**

- 파티셔닝(partitioning)하여 테이블을 관리한다고 가정할 때, 어떤 파티션을 읽었는지를 알려주는 정보다.
- 5.7 이전에는 EXPLAIN PARTITION 명령을 해야 보였으나 8.0 부터는 EXPLAIN 명령만해도 보이게 되었다.

### **type 컬럼**

<aside> 💡 실행 계획이 적절하게 인덱스를 참조했는지를 확인하는데 가장 핵심인 컬럼이다.

</aside>

- ALL을 빼고는 다 인덱스를 참조하긴 했다는것인데 인덱스를 참조했다고해서 무조건 효율적인 것은 아니다.
- 아래 type 컬럼의 종류는 성능이 좋은 순서로 나열했다.
- 참고로 1 부터 9 까지는 일반적으로 효율적인 케이스고 10부터 12까지는 일반적으로 비효율적인 케이스다.

1. **system** : 레코드가 0건 또는 1건만 존재하는 테이블을 접근할 때의 방법 (InnoDB에는 없으니 생략)
2. **const**
    1. 쿼리에 **프라이머리 키**/**유니크 키 컬럼**을 이용하는 **where 조건**에 있으면서 **결과가 반드시 1건**을 반환하는 쿼리로 접근할 때의 방법 (= UNIQUE INDEX SCAN)
    2. 결과가 1개인 것을 쿼리 전에 DBMS가 예측할 수 있어야 한다. (쿼리 실행 후에 결과가 1개인 것은 의미없음)
3. **eq_ref**
    1. 여러 테이블이 JOIN되는 쿼리에서만 발생, JOIN에서 처음 읽은 테이블의 컬럼 값을 **두 번째 이후 읽는 테이블의 프라이머리 키/유니크 인덱스 컬럼(NOT NULL)의 동등 조건에 사용될 때 = 반드시 1건만 존재한다는 보장**이 있을 때 사용되는 접근 방법
4. **ref**
    1. 'eq_ref'와 달리 JOIN 순서에 상관없이 사용되며, 프라이머리 키나 유니크 인덱스 등의 제약도 상관없이 사용된다. 인덱스의 종류와 상관없이 **동등(equal)조건이 사용될 때** 접근 방법이다. (단, 레코드가 반드시 1건이라는 보장이 없으므로 eq_ref보다 느리지만 비교적 느릴 뿐 엄청 빠른 인덱스다.)
5. **fulltext**
    1. MySQL로 전문 검색 인덱스를 사용해서 레코드에 접근하는 방법, 전문 검색할 컬럼에 인덱스가 있어야 한다. **"MATCH ... AGAINST ..." 구문**을 사용해서 실행된다. (잘 안 써봐서 모르겠다...)
6. **ref_or_null**
    1. ref와 같은데 NULL 비교(IS NULL)가 추가된 형태 (실무에서 보기 힘든 형태???)
7. **unique_subquery**
    1. where 조건에 IN (subquery) 형태를 갖을 때, **서브 쿼리에서 중복되지 않는 유니크한 값만 반환될 때** 이 접근 방식을 선택한다.
8. **index_subquery**
    1. N 연산자 특성상 IN 괄호 조건에 나오는 목록에 중복값이 제거 되어야 한다. 유니크하지 않은 경우에 인덱스를 이용하여 중복을 제거하는 케이스다.
9. **range**
    1. 인덱스를 하나의 값이 아니라 **범위로 검색하는 경우**에 사용되는 접근 방법이다. 주로 `<` , `>` , `IS NULL` , `BETWEEN` , `IN` , `LIKE` 등의 연산자로 인덱스를 검색하는 경우다. 통상적으로 '인덱스 스캔이다' 라고하면 range, const, ref를 묶어서 지칭한다.
    2. 위에서 소개한 type 칼럼에서 우선순위(성능)가 낮으나 range 접근 방법도 상당히 빠름
    3. 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있음
10. **index_merge** : **2개 이상의 인덱스를 이용해 각각의 검색결과를 만든 후 결과를 합치는** 접근 방식, 실제 우선순위가 range보다 높지만 생각보다 효율적으로 동작하지 않은 문제가 있다고 한다.
11. **index**
    1. **인덱스를 처음부터 끝까지 읽어야 하는 경우**에 쓰는 접근 방식으로 비효율적이다. 다음 두 가지 조건에서 발생한다. 최악은 아니고 차악정도 느낌이다.
        1. 인덱스 스캔(range, const, ref) 불가능한 경우 + 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우(굳이 데이터파일 읽지 않아도 되는 경우)
        2. 인덱스 스캔(range, const, ref) 불가능한 경우 + 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우(정렬 작업을 피할 수 있는 경우)
    2. 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 사용할 수 있기에 효율적이라 할 수 있다.
12. **ALL**
    1. **풀 테이블 스캔**이다. 일반적인 조회 환경에서 가장 나쁜 방법이지만 억지로 잘못 설계된 인덱스를 타게 하는 경우보다 풀 스캔이 적절할 때도 있긴 있다.

### **possible_keys 컬럼**

<aside> 💡 옵티마이저가 쿼리를 처리하기 위해 여러 처리 방법을 고려하던 중에 사용된 **후보 인덱스 목록**일 뿐이다.

</aside>

### **key 컬럼**

<aside> 💡 possible_keys 컬럼에서 보여진 후보 인덱스 목록 중 **실제 사용된 인덱스**를 의미한다. 인덱스 사용 못했을 경우는 `NULL`로 표기된다.

</aside>

### **key_len 컬럼**

- 실무에서 인덱스를 단일 컬럼으로 만들기 보다는 다중 컬럼으로 만들어지는 경우가 더 많다.
- 이 때 다중 컬럼 인덱스 중에서 몇 바이트까지 사용했는지 알려준다.
- 각 인덱스 컬럼에 할당된 바이트를 알 수 있으니 몇 개의 인덱스 컬럼이 사용되었는지를 추산할 수 있다.

아래 쿼리는 (dept_no, emp_no)로 다중 컬럼(2개)으로 만들어진 프라이머리 키를 포함한 dept_emp테이블을 조회하는 쿼리다.

```
SELECT * FROM dept_emp WHERE dept_no=3;
```

key_len이 4가 나온다고 해보자. 그러면 dept_no 컬럼의 타입이 INTEGER**(4BYTE)**이기 때문에 인덱스(dept_no + emp_no)중에서 앞에 dep_no까지만 쓰였다는 것을 확인할 수 있다.

### **ref 컬럼**

<aside> 💡 type 컬럼에서 접근 방법이 `ref` 이면 어떤 컬럼이 조건에 사용되었는지를 보여준다.

</aside>

- "func"라고 표시될 때도 있는데 이건 단순 컬럼이 아니라 어떤 가공된 컬럼이 사용될 때 나타난다.

### **row 컬럼**

<aside> 💡 옵티마이저가 비용을 산정하기 위해 얼마나 많은 레코드를 읽고 비교해야하는지 예측해본 레코드의 수다.

</aside>

실제 테이블의 레코드 수와 일치하지 않는 경우가 많고 대략적인 통계에 의한 값이다.

### **Extra 컬럼**

<aside> 💡 쿼리 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시됨

내부적인 처리 알고리즘에 대해 조금 더 깊이있는 내용을 보여주는 경우가 많음

옵티마이저가 어떻게 동작하는지에 대해 알려주는 힌트 값

</aside>

- **Impossible HAVING**
    - HAVING 조건에 만족하는 레코드가 없는 경우를 의미한다. = 쿼리를 다시 짜라
- **Impossible WHERE**
    - WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우를 의미한다. = 쿼리 다시 짜라
- **Impossible WHERE noticed after reading const tables**
    - 쿼리를 실행해보기 전엔 WHERE 조건이 항상 false인지는 모르지만 실행해보니까 알게된 경우다. = 쿼리 다시 짜라
    - const 는 상수로 치환되기 때문에 옵티마이저가 쿼리 일부를 실행해보기에 이런 결과가 나올 수 있다.
- **No matching min/max row**
    - MIN(), MAX()와 같은 집합 함수가 있는 쿼리의 WHERE 조건절에 일치하는 레코드가 하나도 없는 경우를 의미한다. = 쿼리 다시 짜라
- **No matching row in const table**
    - const 방식으로 접근할 때 일치하는 레코드가 없는 경우를 의미한다. = 쿼리 다시 짜라
- **Using filesort**
    - ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못하는 경우, MySQL에서 정렬을 한 번 해야하는데 이는 조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬 수행한다.
    - 실무에서 정렬은 거의 필수라 그런지 제일 자주 보이는 비효율적인 케이스라고 볼 수 있다. (= 튜닝 대상이 된다.)
- **Using index**
    - 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 처리할 수 있는 경우(= 커버링 인덱스를 탔을 때)를 의미한다. (극강의 효율이다.)
    - 간혹 type 컬럼의 `index`(=인덱스 풀 스캔)와 Extra 컬럼의 `Using index` (=커버링 인덱스)를 헷갈리는 경우가 있는데 완전 반대되게 비효율적인 것과 효율적인 것이다.
- **Using index for group-by**
    - GROUP BY 처리를 위해 (이미 정렬된) 인덱스를 이용하는 경우 즉 루스 인덱스 스캔을 의미한다.
- **Using temporary**
    - MySQL이 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 **임시 테이블**을 사용한다. 임시테이블이 사용되었을 경우에 나타나는데 임시 테이블을 썼을 때 안 나타나기도 한다(?)
    - FROM 절에 서브쿼리를 쓰면 무조건 임시테이블(Derived table)이 생성된다.
    - "COUNT(DISTINCT column1)"를 포함하는 쿼리도 인덱스를 사용할 수 없는 경우에 임시 테이블이 만들어진다.
    - UNION, UNION ALL이 사용된 쿼리도 항상 임시 테이블을 사용한다.
    - 인덱스를 사용하지 못하는 정렬 작업도 임시 테이블을 사용한다.
- **Using where**
    - **MySQL엔진**이 별도의 가공, 필터링 작업을 처리한 경우일 때만 나타난다. 범위 조건은 스토리지 엔진에서 처리되어 레코드를 리턴해주지만, 체크 조건은 MySQL엔진에서 처리된다. (5.1 플러그인 버전부터는 이렇게 불합리하게 처리되지 않는다고 한다. keyword : condition push down)

```sql
SELECT * FROM employees WHERE emp_no BETWEEN 100 AND 110 AND gender = 'F';
-- 범위조건 BETWEEN은 스토리지 엔진에 의해 10개의 레코드가 리턴되고-- 10개중에 체크 조건 gender='F' 인 것을 MySQL엔진에 의해 필터링되어 Using Where 등장
```

### **Filtered 컬럼**

- Extra 컬럼에 표시되는 "Using where"이 스토리지 엔진이 리턴해준 레코드들을 MySQL엔진이 필터링하면 등장한다는 것을 알았다.

그런데 정확하게 얼마나 많은 레코드가 필터링되었는 알 수 없었다.

이것을 표현하는 것이 Filtered 컬럼의 역할이다.

Filtered 컬럼을 확인하려면 `EXPLAIN` 키워드에 추가로 `EXTENDED` 키워드를 붙이면 된다.

```sql
EXPLAIN EXTENDED
SELECT * FROM employees
WHERE emp_no BETWEEN 100 AND 110 AND gender = 'F';
```

그러면 Filtered 컬럼에 값이 나오는데 이 값은 필터링, 가공 후 레코드가 몇 퍼센트(%)나 남았을지를 알려준다.

웃긴건 이것도 실제 값이 아니라 **통계 예측 값**이라는 것이다...

MySQL 8.0에서는 그냥 EXPLAIN으로 나온다.

## 8.1 디스크 읽기 방식

데이터베이스 성능 튜닝은 디스크 I/O를 어떻게 줄이느냐가 관건임.

### 8.1.1 하드 디스크 드라이브(HDD) 와 솔리드 스테이트 드라이브(SSD)

- SSD는 HDD의 원판을 제거하고 플래시 메모리를 장착
    - 디스크를 회전시킬 필요가 없어 빠름
    - 속도는 DRAM > SSD  > HDD
- SSD는 HDD보다 랜덤 I/O에서 속도가 빠름

### 8.1.2 랜덤 I/O와 순차 I/O

- 차이
    - 시스템 콜 횟수가 차이남. 순차 I/O는 1번, 랜덤 I/O는 N번으로 디스크를 돌리는 횟수가 차이남.
    - 디스크 헤드 위치 이동의 빈도가 디스크 성능의 주 요인임

## 8.2 인덱스란?

- 비유를 통한 설명
    - 색인 - 인덱스
    - 책의 내용 - 데이터 파일
    - 책의 페이지 - 데이터 주소
- 인덱스는 정렬되어 있음
    - 인덱스의 존재로 INSERT, UPDATE, DELETE 작업은 느려지고, 조회는 빨라짐
- 인덱스 분류
    - PK와 세컨더리 인덱스
    - B-Tree 와 Hash 인덱스
    - 유니크 인덱스와 논유니크 인덱스
        - 유니크하다는 정보는 조회 시 항상 1건의 결과를 보장하므로 중요한 정보임
     

## 8.3 B-Tree 인덱스

- B-Tree에서 B는 Binary(이진)의 약자가 아닌 Balanced를 의미함

### 8.3.1 구조 및 특성
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/df85b3ad-8640-42f4-be23-45c8e00ef763)
- B-Tree의 기본 구조는 최상위에 루트 노드가 존재하고, 가장 하위에 리프 노드, 그 사이에 브랜치 노드가 존재함
- 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주솟값을 보유함
- 인덱스는 키 칼럼만 가지므로 인덱스가 아닌 칼럼을 읽으려면 데이터 레코드에 접근해야 함
    ![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/9aa7f470-0c0f-4081-8a44-be4bc5c72920)
    - InnoDB는 데이커 레코드 접근 시 리프 노드가 보유한 PK로 PK 인덱스를 한번 더 검색하여 PK 인덱스의 리프 노드에 있는 데이터 레코드를 읽음
 
### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- 저장될 키의 위치를 탐색하고 리프 노드에 저장함. 리프 노드가 꽉 차면 분리 작업이 일어남.
- 테이블에 레코드 추가 비용이 1이라면 인덱스 키 추가는 1.5임
- InnoDB는 체인지 버퍼를 활용하여 지연 처리 가능함. 단, 유니크 인덱스는 실시간으로 유니크함을 판별해야하므로 체인지 버퍼를 활용할 수 없음.

**인덱스 키 삭제**

- 키 값이 저장된 리프 노드를 찾아 삭제 마킹만 하면 됨

**인덱스 키 변경**

- 키 값에 따라 위치가 지정되므로 단순 변경은 불가능함. 먼저 키 값을 삭제하고 추가하는 형태로 처리됨.

**인덱스 키 검색**

- 인덱스를 구축하는 주된 목적임
- 루트 노드부터 리프 노드까지 비교 작업을 수행함. 이를 트리 탐색이라고 함.
- 인덱스 키 값의 뒷부분 검색 용도로는 사용 불가능함
- 인덱스 키 값 변경 이후 비교 시에도 사용 불가능함
- InnoDB에서 잠금 시 인덱스를 잠금(레코드 락, 넥스트 키 락)함. 인덱스가 적절하지 않으면 불필요하게 많은 레코드가 잠김.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키 값의 크기**

- InnoDB 데이터 저장 단위는 페이지임. 이는 모든 디스크 I/O의 단위임.
    - 루트, 브랜치, 리프 노드 구분 기준이 페이지임
- InnoDB에서 `innodb_page_size` 시스템 변수로 페이지 크기를 4KB ~ 64KB로 지정 가능함. 기본 값은 16KB임.
- 인덱스 키 값이 커지면 한 페이지 안에 담을 수 있는 키 수가 줄어듬. 이는 디스크 읽기 횟수를 늘리게 됨.
- 인덱스 키 값이 커질수록 메로리에 캐시할 수 있는 레코드 수도 줄어듬

**B-Tree 깊이**

- B-Tree 깊이는 디스크 읽기 횟수와 직접적 연관이 있으므로 중요함. 다만, 직접 제어할 방법은 없음.
- 인덱스 키 값이 커지면 한 페이지에 담을 수 있는 키 수가 줄어들고, 그로 인해 페이지 수가 늘어나 깊이가 증가함. 그로 인해 디스크 읽기도 증가함.

**선택도(기수성)**

- 인덱스 키 값 중 유니크한 키의 수를 의미함
- 선택도가 높을수록 검색 수가 줄어들어서 효율적임

**읽어야 하는 레코드의 건수**

- 인덱스를 통해 레코드를 읽는게 직접 레코드를 읽는 방식보다 비용이 높음
    - 일반적으로 옵티마이저가 인덱스를 통한 방식이 4~5배 더 오래 걸린다고 예측함
- 인덱스로 읽는 레코드가 전체 레코드의 20~25%가 넘으면 풀 테이블 스캔이 더 효율적임

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

**인덱스 레인지 스캔**
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/c9fb319b-30c0-4149-9c83-a094950bdbeb)
- 인덱스의 접근 방법 중 가장 대표적이고, 빠른 방식 중 하나임
- 검색해야할 인덱스의 범위가 결정됐을 때 사용함
- 시작 지점을 찾으면 그때부터 리프노드만 읽으면 됨
- 리프 노드의 끝에 다다르면 리프 노드 간의 링크를 통해 다음 리프 노드로 이동함
- 인덱스 리프 노드를 스캔하며 실제 데이터 레코드를 읽어와야 하는 경우
    ![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/d08a929a-fcca-4f27-bc15-78f7b452b0ac)
    - 리프 노드에 저장된 레코드 주소로 데이터를 읽는데, 이때마다 랜덤 I/O가 일어남
- 레인지 스캔 과정 3단계
    1. 쿼리 조건에 만족하는 값의 위치를 인덱스에서 찾음. 이를 인덱스 탐색이라고 함.
    2. 탐색된 위치에서 필요만큼 스캔함
    3. 읽은 인덱스 키와 레코드 주소로 레코드 페이지를 가져옴
    - 쿼리가 인덱스로 지정된 칼럼만 필요로 하는 경우 3번 단계가 생략됨. 이를 커버링 인덱스라고 함. 디스크이 레코드를 읽지 않아도 되니 랜덤 I/O가 줄어듬.

**인덱스 풀 스캔**

- 인덱스의 처음부터 끝까지 다 읽는 경우
    - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 대표적으로 사용됨
- 인덱스 뿐만아니라 데이터 레코드까지 읽어야 하면 절대 사용되지 않음
    - 쿼리가 인덱스만으로 처리될 때나 주로 사용됨. 이 경우에는 테이블 풀 스캔보다 효율적임.
- 인덱스를 사용하는 목적과는 달라서 인덱스 풀 스캔은 비효율적인 방식에 속함

**루스 인덱스 스캔**

- 듬성듬성하게 인덱스를 읽는 방식
    
    ```sql
    SELECT dept_no, MIN(emp_no)
    FROM dept_emp
    WHERE dep_no BETWEEN 'd002' AND 'd004'
    GROUP BY dept_no;
    
    // (dept_no, emp_no) 로 인덱스 생성되어 있음
    ```
    
    - dept_no 그룹 별로 첫번째 레코드의 emp_no만 읽으면 됨
    

**인덱스 스킵 스캔**
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/1163c079-68b7-4757-a85c-b98c6afb14ff)
- (gender, birth_date)로 인덱스가 생성되어 있을 때, 쿼리 조건에 gender가 없으면 인덱스 풀 스캔으로 동작하여 효율적으로 사용하지 못함
- 인덱스 스킵 스캔 기능을 활성화하면 내부적으로 gender에서 유니크한 값을 모두 조회하여 gender가 조건에 없던 쿼리에 gender 조건을 추가하여 처리함
- 8.0 버전 이후에 새로 도입되어 단점이 존재함
    - WHERE 조건절에 없는 인덱스 선행 칼럼의 유니크 갯수가 적어야 함
        - 유니크 값이 많다면 스캔 시작 지점 탐색이 많아져 성능이 악화됨
    - 쿼리가 인덱스에 존재하는 칼럼만으로 처리되어야 함
        - 옵티마이저가 개선되면 해결될 여지 있음
    

### 8.3.5 다중 칼럼 인덱스

- 다중 칼럼 인덱스에서 뒤의 칼럼은 앞선 칼럼에 의존해서 정렬됨. 그렇기에 칼럼 순서가 아주 중요함.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스 생성 시 오름차순 또는 내림차순으로 저장 가능함
    - 읽을 때도 정해진 방향으로만 가능한 것은 아님
    - 읽는 방향은 옵티마이저가 판단함

**인덱스의 정렬**

- 8.0 이후부터는 (team_name ASC, user_score DESC) 처럼 정렬 순서를 혼합하여 인덱스 생성 가능함

**인덱스 역순 스캔이 인덱스 정순 스캔보다 느린 이유**

- 페이지 잠금이 인덱스 정순에 적합한 구조임
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조임

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 쿼리의 WHERE, GROUP BY, ORDER BY가 어떤 경우에 인덱스를 사용 가능하고, 어떤 방식으로 사용 가능한지 알아야 함

**비교 조건의 종류와 효율성**

- 작업의 범위를 결정하는 조건 → 작업 범위 결정 조건
- 작업 범위를 줄이지 않고 단순 거름종이 역할만 하는 조건 → 필터링 조건 or 체크 조건
- 작업 범위 결정 조건이 많을 수록 성능이 향상됨, 체크 조건은 성능과 상관 없고 오히려 성능 악화 가능성이 존재함

**인덱스의 가용성**

- B-Tree는 왼쪽 값에 기준하여 오른쪽 값이 정렬되어 있음
    - 왼쪽 부분이 없으면 인덱스 레인지 스캔이 불가능함

**가용성과 효율성 판단**

- 작업 범위 결정 조건으로 사용 불가한 경우
    - NOT-EQUAL로 비교된 경우(NOT IN, NOT BETWEEN, IS NOT NULL)
    - LIKE%?? 형태로 문자열 패턴이 비교된 경우
    - 인덱스 칼럼이 변경된 후 비교된 경우
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - 데이터 타입이 서로 다른 비교
    - 문자열 데이터 타입 콜레이션이 다른 경우
- 다중 인덱스가 사용 불가한 경우
    - 맨 앞 인덱스 칼럼에 대한 조건이 쿼리에 없는 경우
    - 맨 앞 인덱스 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건인 경우

## 8.1 디스크 읽기 방식

데이터베이스 성능 튜닝은 디스크 I/O를 어떻게 줄이느냐가 관건임.

### 8.1.1 하드 디스크 드라이브(HDD) 와 솔리드 스테이트 드라이브(SSD)

- SSD는 HDD의 원판을 제거하고 플래시 메모리를 장착
    - 디스크를 회전시킬 필요가 없어 빠름
    - 속도는 DRAM > SSD  > HDD
- SSD는 HDD보다 랜덤 I/O에서 속도가 빠름

### 8.1.2 랜덤 I/O와 순차 I/O

- 차이
    - 시스템 콜 횟수가 차이남. 순차 I/O는 1번, 랜덤 I/O는 N번으로 디스크를 돌리는 횟수가 차이남.
    - 디스크 헤드 위치 이동의 빈도가 디스크 성능의 주 요인임

## 8.2 인덱스란?

- 비유를 통한 설명
    - 색인 - 인덱스
    - 책의 내용 - 데이터 파일
    - 책의 페이지 - 데이터 주소
- 인덱스는 정렬되어 있음
    - 인덱스의 존재로 INSERT, UPDATE, DELETE 작업은 느려지고, 조회는 빨라짐
- 인덱스 분류
    - PK와 세컨더리 인덱스
    - B-Tree 와 Hash 인덱스
    - 유니크 인덱스와 논유니크 인덱스
        - 유니크하다는 정보는 조회 시 항상 1건의 결과를 보장하므로 중요한 정보임
     

## 8.3 B-Tree 인덱스

- B-Tree에서 B는 Binary(이진)의 약자가 아닌 Balanced를 의미함

### 8.3.1 구조 및 특성
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/df85b3ad-8640-42f4-be23-45c8e00ef763)
- B-Tree의 기본 구조는 최상위에 루트 노드가 존재하고, 가장 하위에 리프 노드, 그 사이에 브랜치 노드가 존재함
- 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주솟값을 보유함
- 인덱스는 키 칼럼만 가지므로 인덱스가 아닌 칼럼을 읽으려면 데이터 레코드에 접근해야 함
    ![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/9aa7f470-0c0f-4081-8a44-be4bc5c72920)
    - InnoDB는 데이커 레코드 접근 시 리프 노드가 보유한 PK로 PK 인덱스를 한번 더 검색하여 PK 인덱스의 리프 노드에 있는 데이터 레코드를 읽음
 
### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- 저장될 키의 위치를 탐색하고 리프 노드에 저장함. 리프 노드가 꽉 차면 분리 작업이 일어남.
- 테이블에 레코드 추가 비용이 1이라면 인덱스 키 추가는 1.5임
- InnoDB는 체인지 버퍼를 활용하여 지연 처리 가능함. 단, 유니크 인덱스는 실시간으로 유니크함을 판별해야하므로 체인지 버퍼를 활용할 수 없음.

**인덱스 키 삭제**

- 키 값이 저장된 리프 노드를 찾아 삭제 마킹만 하면 됨

**인덱스 키 변경**

- 키 값에 따라 위치가 지정되므로 단순 변경은 불가능함. 먼저 키 값을 삭제하고 추가하는 형태로 처리됨.

**인덱스 키 검색**

- 인덱스를 구축하는 주된 목적임
- 루트 노드부터 리프 노드까지 비교 작업을 수행함. 이를 트리 탐색이라고 함.
- 인덱스 키 값의 뒷부분 검색 용도로는 사용 불가능함
- 인덱스 키 값 변경 이후 비교 시에도 사용 불가능함
- InnoDB에서 잠금 시 인덱스를 잠금(레코드 락, 넥스트 키 락)함. 인덱스가 적절하지 않으면 불필요하게 많은 레코드가 잠김.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키 값의 크기**

- InnoDB 데이터 저장 단위는 페이지임. 이는 모든 디스크 I/O의 단위임.
    - 루트, 브랜치, 리프 노드 구분 기준이 페이지임
- InnoDB에서 `innodb_page_size` 시스템 변수로 페이지 크기를 4KB ~ 64KB로 지정 가능함. 기본 값은 16KB임.
- 인덱스 키 값이 커지면 한 페이지 안에 담을 수 있는 키 수가 줄어듬. 이는 디스크 읽기 횟수를 늘리게 됨.
- 인덱스 키 값이 커질수록 메로리에 캐시할 수 있는 레코드 수도 줄어듬

**B-Tree 깊이**

- B-Tree 깊이는 디스크 읽기 횟수와 직접적 연관이 있으므로 중요함. 다만, 직접 제어할 방법은 없음.
- 인덱스 키 값이 커지면 한 페이지에 담을 수 있는 키 수가 줄어들고, 그로 인해 페이지 수가 늘어나 깊이가 증가함. 그로 인해 디스크 읽기도 증가함.

**선택도(기수성)**

- 인덱스 키 값 중 유니크한 키의 수를 의미함
- 선택도가 높을수록 검색 수가 줄어들어서 효율적임

**읽어야 하는 레코드의 건수**

- 인덱스를 통해 레코드를 읽는게 직접 레코드를 읽는 방식보다 비용이 높음
    - 일반적으로 옵티마이저가 인덱스를 통한 방식이 4~5배 더 오래 걸린다고 예측함
- 인덱스로 읽는 레코드가 전체 레코드의 20~25%가 넘으면 풀 테이블 스캔이 더 효율적임

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

**인덱스 레인지 스캔**
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/c9fb319b-30c0-4149-9c83-a094950bdbeb)
- 인덱스의 접근 방법 중 가장 대표적이고, 빠른 방식 중 하나임
- 검색해야할 인덱스의 범위가 결정됐을 때 사용함
- 시작 지점을 찾으면 그때부터 리프노드만 읽으면 됨
- 리프 노드의 끝에 다다르면 리프 노드 간의 링크를 통해 다음 리프 노드로 이동함
- 인덱스 리프 노드를 스캔하며 실제 데이터 레코드를 읽어와야 하는 경우
    ![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/d08a929a-fcca-4f27-bc15-78f7b452b0ac)
    - 리프 노드에 저장된 레코드 주소로 데이터를 읽는데, 이때마다 랜덤 I/O가 일어남
- 레인지 스캔 과정 3단계
    1. 쿼리 조건에 만족하는 값의 위치를 인덱스에서 찾음. 이를 인덱스 탐색이라고 함.
    2. 탐색된 위치에서 필요만큼 스캔함
    3. 읽은 인덱스 키와 레코드 주소로 레코드 페이지를 가져옴
    - 쿼리가 인덱스로 지정된 칼럼만 필요로 하는 경우 3번 단계가 생략됨. 이를 커버링 인덱스라고 함. 디스크이 레코드를 읽지 않아도 되니 랜덤 I/O가 줄어듬.

**인덱스 풀 스캔**

- 인덱스의 처음부터 끝까지 다 읽는 경우
    - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 대표적으로 사용됨
- 인덱스 뿐만아니라 데이터 레코드까지 읽어야 하면 절대 사용되지 않음
    - 쿼리가 인덱스만으로 처리될 때나 주로 사용됨. 이 경우에는 테이블 풀 스캔보다 효율적임.
- 인덱스를 사용하는 목적과는 달라서 인덱스 풀 스캔은 비효율적인 방식에 속함

**루스 인덱스 스캔**

- 듬성듬성하게 인덱스를 읽는 방식
    
    ```sql
    SELECT dept_no, MIN(emp_no)
    FROM dept_emp
    WHERE dep_no BETWEEN 'd002' AND 'd004'
    GROUP BY dept_no;
    
    // (dept_no, emp_no) 로 인덱스 생성되어 있음
    ```
    
    - dept_no 그룹 별로 첫번째 레코드의 emp_no만 읽으면 됨
    

**인덱스 스킵 스캔**
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/1163c079-68b7-4757-a85c-b98c6afb14ff)
- (gender, birth_date)로 인덱스가 생성되어 있을 때, 쿼리 조건에 gender가 없으면 인덱스 풀 스캔으로 동작하여 효율적으로 사용하지 못함
- 인덱스 스킵 스캔 기능을 활성화하면 내부적으로 gender에서 유니크한 값을 모두 조회하여 gender가 조건에 없던 쿼리에 gender 조건을 추가하여 처리함
- 8.0 버전 이후에 새로 도입되어 단점이 존재함
    - WHERE 조건절에 없는 인덱스 선행 칼럼의 유니크 갯수가 적어야 함
        - 유니크 값이 많다면 스캔 시작 지점 탐색이 많아져 성능이 악화됨
    - 쿼리가 인덱스에 존재하는 칼럼만으로 처리되어야 함
        - 옵티마이저가 개선되면 해결될 여지 있음
    
### 8.3.5 다중 칼럼 인덱스

- 다중 칼럼 인덱스에서 뒤의 칼럼은 앞선 칼럼에 의존해서 정렬됨. 그렇기에 칼럼 순서가 아주 중요함.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스 생성 시 오름차순 또는 내림차순으로 저장 가능함
    - 읽을 때도 정해진 방향으로만 가능한 것은 아님
    - 읽는 방향은 옵티마이저가 판단함

**인덱스의 정렬**

- 8.0 이후부터는 (team_name ASC, user_score DESC) 처럼 정렬 순서를 혼합하여 인덱스 생성 가능함

**인덱스 역순 스캔이 인덱스 정순 스캔보다 느린 이유**

- 페이지 잠금이 인덱스 정순에 적합한 구조임
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조임

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 쿼리의 WHERE, GROUP BY, ORDER BY가 어떤 경우에 인덱스를 사용 가능하고, 어떤 방식으로 사용 가능한지 알아야 함

**비교 조건의 종류와 효율성**

- 작업의 범위를 결정하는 조건 → 작업 범위 결정 조건
- 작업 범위를 줄이지 않고 단순 거름종이 역할만 하는 조건 → 필터링 조건 or 체크 조건
- 작업 범위 결정 조건이 많을 수록 성능이 향상됨, 체크 조건은 성능과 상관 없고 오히려 성능 악화 가능성이 존재함

**인덱스의 가용성**

- B-Tree는 왼쪽 값에 기준하여 오른쪽 값이 정렬되어 있음
    - 왼쪽 부분이 없으면 인덱스 레인지 스캔이 불가능함

**가용성과 효율성 판단**

- 작업 범위 결정 조건으로 사용 불가한 경우
    - NOT-EQUAL로 비교된 경우(NOT IN, NOT BETWEEN, IS NOT NULL)
    - LIKE%?? 형태로 문자열 패턴이 비교된 경우
    - 인덱스 칼럼이 변경된 후 비교된 경우
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - 데이터 타입이 서로 다른 비교
    - 문자열 데이터 타입 콜레이션이 다른 경우
- 다중 인덱스가 사용 불가한 경우
    - 맨 앞 인덱스 칼럼에 대한 조건이 쿼리에 없는 경우
    - 맨 앞 인덱스 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건인 경우

## 8.5 전문 검색 인덱스

- B-Tree 인덱스는 실제 칼럼의 값이 1MB 여도 3072바이트까지 잘라서 인덱스 키로 사용함. 또한, 전체 일치 혹은 좌측 일부 일치와 같은 검색만 가능함
- 문서 내용 전체를 인덱스화하여서 특정 키워드가 포함된 문서를 검색하는 전문 검색과 같은 경우는 전문 검색 인덱스가 필요함

### 8.5.1 인덱스 알고리즘

- 전문 검색은 문서 내용에서 사용자가 검색할 키워드를 분석하여 인덱스로 구축함
    - 어근 분석 알고리즘
    - n-gram 분석 알고리즘

**어근 분석 알고리즘** 

- 전문 검색 인덱스는 아래 2가지 과정을 거쳐 인덱스를 구축함
    - 불용어 처리
    - 어근 분석
- 불용어 처리는 필요성이 떨어지는 단어를 필터링하여 제거하는 것임. 보통 코드 내에서 상수로 처리하거나 데이터베이스화하여 저장해놓음
- 어근 분석은 검색어로 선정된 단어의 원형을 찾는 작업임. MeCab 라이브러리를 활용할 수 있음
    - 한국어, 일본어는 단어 변형이 거의 없어서 명사와 조사를 구분하는 것이 중요함
    - 서구권 언어를 위해서는 Snowball이 주로 사용됨
- MeCab이 제대로 동작하기 위해서는 단어 사전과 품사를 식별하기 위한 문장 구조 인식이 필요함. 이를 위해선 많은 시간이 드는 학습 과정이 필요함.

**n-gram 알고리즘**

- MeCab을 활용하면 인덱스 구축을 위해서 많은 리소스가 필요함. 이를 보완하기 위해 n-gram 알고리즘이 등장함
- n-gram 알고리즘은 문장을 이해하는 어근 분석과는 달리 단순히 키워드를 뽑아내는 알고리즘임
    - n-gram 알고리즘은 본문을 몇 글자씩 잘라서 인덱싱하는 방법임
    - n은 잘라낼 최소 글자 수를 의미하는데 일반적으로 2글자씩 자름
- 2-gram 알고리즘에서 각 글자를 중첩해서 2글자씩 토큰으로 구분함
    - 10글자 단어라면 (10-1)개 토큰으로 분리됨
- 생성된 토큰에서 불용어들을 걸러냄
    - 불용어는 `information_schma.innodb_ft_default_stopword` 테이블에서 확인 가능함

**불용어 변경 및 삭제**

- 설정된 불용어를 통한 처리는 오히려 헷갈리게 만들거나 도움이 안될 수 있음. 불용어 처리를 무시하거나 사용자가 직접 등록하는 방법이 자주 쓰임.
- 불용어 처리 무시 방법
    - my.cnf 파일의 `ft_stopword_file` 시스템 변수에 빈 문자열을 설정하여 MySQL 서버의 모든 전문 검색 인덱스에 불용어를 제거함
        - MySQL 서버를 재시작해야 반영됨
    - InnoDB 테이블의 전문 검색 인덱스의 불용어 처리를 무시하려면 `innodb_ft_enable_stopword` 시스템 변수를 OFF 처리하면 됨
        - 동적 변수이므로 실행 중에서도 변경 가능
- 사용자 정의 불용어 사용 방법
    - 불용어 파일을 만들어 놓고 my.cnf 파일의 `ft_stopword_file` 시스템 변수에 불용어 파일의 경로를 등록함
    - InnoDB 사용하는 경우 불용어 목록을 테이블로 저장하고, `innodb_ft_server_stopword_table` 시스템 변수에 테이블을 설정하면 됨

### 8.5.2 전문 검색 인덱스의 가용성

- 전문 검색 인덱스를 사용하기 위한 조건
    - 쿼리 문장이 전문 검색을 위한 문법(MATCH … AGAINST …)을 사용
    - 테이블이 전문 검색 대상 칼럼에 대해 전문 인덱스 보유

## 8.7 멀티 밸류 인덱스

- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 인덱스 키 1건을 가짐
- 멀티 밸류 인덱스는 하나의 레코드가 여러 인덱스 키를 가질 수 있는 인덱스임
    - RDBMS 가 JSON 타입을 지원하면서 JSON 배열 필드 원소에 대한 인덱스가 등장하게 됨
- 멀티 밸류 인덱스를 활용하기 위해서는 아래 함수들을 반드시 이용하여 검색해야 함
    - MEMBER OF()
    - JSON_CONTAINS()
    - JSON_OVERLAPS()

## 8.8 클러스터링 인덱스

- MySQL에서 클러스터링 인덱스는 InnoDB에서만 지원함

### 8.8.1 클러스터링 인덱스
![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/cf142870-1ad1-48fe-9286-f17e43e50c86)
- 테이블의 PK에 대해서만 적용됨
- PK 값에 의해 레코드의 저장 위치가 결정됨. 즉, PK 값이 변경되면 레코드의 저장 위치도 변경됨.
    - 키 기반의 검색이 매우 빠른 대신 레코드 저장, PK 변경이 상대적으로 느림
- 세컨더리 인덱스를 위한 B-Tree 인덱스의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 모든 칼럼이 다 저장되어 있음
- PK가 없는 InnoDB 테이블이 클러스터링되는 방식
    1. PK가 있으면 PK를 클러스터링 키로 선택
    2. NOT NULL 옵션의 유니크 인덱스 중 첫번째 인덱스를 클러스터링 키로 선택
    3. 자동으로 유니크한 값을 가지고 증가하는 칼럼을 내부적으로 만들고, 클러스터링 키로 선택

### 8.8.2 세컨더리 인덱스에 미치는 영향

- InnoDB 테이블에서 MyISAM 처럼 세컨더리 인덱스가 실제 레코드의 주소를 들고 있다면 PK가 변경될 때마다 레코드 주소가 변경되고 모든 인덱스를 변경해줘야할 것임
    - 이를 방지하고자 InnoDB에서는 세컨더리 인덱스가 실제 주소가 아닌 PK를 저장함

### 8.8.3 클러스터링 인덱스의 장점과 단점

- 장점
    - PK로 검색 시 성능이 매우 빠름
    - 모든 세컨더리 인덱스가 PK를 가지므로 인덱스만으로 처리되는 경우가 많음
- 단점
    - PK 값의 크기가 클 경우 전체적인 인덱스 크기가 커짐
    - 세컨더리 인덱스로 검색 시 PK로 다시 검색해야하므로 느림
    - INSERT 시 PK로 저장 위치가 결정되기에 느림
    - PK 변경 시 DELETE 후 INSERT 작업으로 진행되기에 느림
- 일반적인 서비스에서 읽기와 쓰기의 비율이 평균 8:2 ~ 9:1 이므로 쓰기의 느림을 감수하고 빠르게 읽는 것이 이득임

### 8.8.4 클러스터링 테이블 사용 시 주의사항

**클러스터링 인덱스 키의 크기**

- 모든 세컨더리 인덱스가 PK를 포함함. PK가 커지면 모든 세컨더리 인덱스가 커짐.

**프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)**

- PK는 검색에 자주 이용되고, 빠른 성능을 보임
- 칼럼의 크기가 크더라도 업부적으로 해당 레코드를 대표한다면 그 칼럼을 PK로 지정하는 것이 좋을 수 있음

**프라이머리 키는 반드시 명시할 것**

- AUTO_INCREMENT 칼럼을 이용해서라도 PK는 명시해야 함
- 명시하지 않으면 내부적으로 스스로 칼럼을 추가하는데, 이때는 사용자가 전혀 사용할 수 없음
- ROW 기반 복제나 InnoDB Cluseter에서 PK를 가져야 정상적인 성능을 보장함

**AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우**

- 세컨더리 인덱스도 필요하고 PK 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하는 것이 좋음

## 8.9 유니크 인덱스

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 구조상 둘 간의 차이는 없음. 읽기와 쓰기 성능 관점에서 살펴보도록 하자.

**인덱스 읽기**

- 일반 세컨더리 인덱스에서 추가적으로 해야하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼 값을 비교하는 것이기에 성능상 큰 차이 없음
    - 일반 세컨더리 인덱스는 읽어야 하는 레코드 수가 많아져서 느린 것이지 인덱스 특성 떄문에 느린 것이 아님

**인덱스 쓰기**

- 유니크 인덱스 키 값을 쓸 때는 중복된 값이 있는지 체크하는 과정이 필요해서 느림
- MySQL은 중복된 값 체크 시 읽기 잠금, 쓰기 시 쓰기 잠금을 하여 데드락 발생 가능함
- 일반적으로 인덱스 키 쓰기 작업 시 체인지 버퍼를 활용하여 지연 처리를 하는데 유니크 인덱스는 실시간 중복 체크를 해야하므로 체인지 버퍼를 활요하지 못함. 그래서 상대적으로 더 느림.

### 8.9.2 유니크 인덱스 사용 시 주의사항

- 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 할 수 있으므로 중복해서 생성할 필요 없음
- 유일성이 꼭 보장되야하는 칼럼이 아니라면 일반 세컨더리 인덱스를 생성하자

## 8.10 외래키

- 외래키는 InnoDB 스토리지 엔진에서만 생성 가능함
- 외래키 제약이 설정되면 자동으로 연관 테이블 칼럼에 인덱스까지 생성됨
    - 외래키 제거 없이 자동 생성된 인덱스를 삭제할 수 없음
- 외래키 관리 시 중요한 특징
    - 테이블 변경이 발생하는 경우 잠금 경합이 발생
    - 외래키와 연관되지 않은 칼럼의 변경은 잠금 경합이 발생하지 않음

### 8.10.1 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요함. 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해당 쓰기 잠금이 해제될 때까지 기다림.
    - 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음

### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

- 자식 테이블이 생설될 때 외래키에 ON DELETE CASCADE 가 설정되었다고 하자
- 부모키를 참조하는 자식 레코드를 변경하는 중에 부모키에 해당하는 부모 레코드를 삭제하면 부모 레코드는 자식 레코드에 대한 쓰기 잠금이 해제되기를 기다려야 함
    - 자식 테이블이 생성될 때 정의된 ON DELETE CASCADE 때문에 부모 레코드가 삭제되면 자식도 동시에 삭제되기 때문임. 즉, 연관된 자식을 삭제해야하는데 변경에 의한 쓰기 잠금이 있으니 쓰기 잠금이 해제될 때까지 대기하는 것임
- 외래키가 있으면 자식 테이블에 레코드가 추가될 때 부모 테이블에 해당 외래키가 존재하는지 체크함. 이 체크를 위해 읽기 잠금이 걸리는데 이는 동시성 처리에 영향을 줌.

## 디스크 읽기 방식
### HDD와 SSD
- CPU나 메모리는 전자식이지만 하드 디스크 드라이브(HDD)는 기계식이기 때문에 DB 서버에서 디스크 장치는 병목이 된다.
- SSD는 HDD의 느리다는 단점을 극복하고자 탄생한 전자식 저장 매체이다.
	- RAM 보다는 느리지만 디스크 보다는 훨씬 빠름
- SSD의 장점은 HDD보다 랜덤 I/O가 훨씬 빠르다는 것이다.
	- 순차 I/O는 크게 차이는 없음
### 랜덤 I/O와 순차 I/O
- HDD나 SSD 모두 랜덤 I/O가 순차 I/O보다 더 느리다. 
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄이는게 목적이라 할 수 있다.
	- 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것
	- 참고로 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업은 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.

## 인덱스란 ?
- 책의 '찾아보기'라 생각하면 된다.
- 칼럼 값과 해당 레코드가 저장된 주소를 키-값 쌍으로 삼아 인덱스를 만들어 둔다.
- 인덱스는 칼럼 값을 기준으로 항상 정렬되어 있다.
	- 반면에 데이터 파일의 데이터는 그냥 저장된 순서대로 나열되어 있다.
- 인덱스는 데이터를 삽입할 때마다 다시 정렬해야 하기 때문에 INSERT, UPDATE, DELETE 성능이 느리다.
	- 반면에 읽기 성능은 빠르다.
- 분류
	- 역할
		- 프라이머리 키(인덱스) : 레코드를 대표하는 칼럼(기본키)로 만들어진 인덱스를 의미한다. 프라이머리 키는 `NULL` 값과 중복을 허용하지 않는다.
		- 세컨더리 인덱스 : 프라이머리 키를 제외한 나머지 인덱스를 말한다. 그 중에서 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체할 수도 있다. 
	- 저장 방식
		- B-Tree 인덱스 : 일반적으로 가장 많이 사용하는 인덱스 알고리즘으로, 칼럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱을 하는 알고리즘이다.
		- Hash 인덱스 : 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 단일 검색은 굉장히 빠르지만 범위 검색에는 사용할 수 없다.

## B-Tree 인덱스

![](https://i.imgur.com/VP80cCf.png)

- 가장 많이 사용되며, 변형된 버전인 B+Tree, B*-Tree가 주로 사용된다.
- 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다. 
### 구조 및 특성
- **구조**
	- 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
		- 최상단을 루트 노드, 중간을 브랜치 노드, 가장 밑단을 리프 노드라 한다.
- **특징**
	- 인덱스와 실제 데이터는 다른 저장공간에 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가진다.
	-  인덱스 키 값은 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다.
		- 일반적으로 삽입한 순서대로 저장되지만, DELETE, INSERT가 반복되면서 의미가 없어짐
		- 다만, InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장하므로 기본적으로 **프라이머리 키 순서대로 정렬**된다. 
	- 인덱스에는 테이블의 키 칼럼만 저장되어 있기 때문에 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 
		- 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다(MyISAM). 
		- InnoDB같은 경우, 리프 노드에 프라이머리 키가 저장되어 있는데, 이를 바탕으로 다시 트리 구조의 클러스터드 인덱스를 탐색하는 과정을 거쳐야 한다.

![](https://i.imgur.com/zq0wNY2.png)

*MyISAM 엔진에서 인덱스를 통해 데이터 파일의 데이터에 접근하는 과정*

![](https://i.imgur.com/Nxb53bM.png)

*InnoDB 엔진에서 인덱스를 통해 데이터 파일의 데이터에 접근하는 과정*
### B-Tree 인덱스 키 추가 및 삭제
- **인덱스 키 추가**
	- 새로운 키 값이 B-Tree에 저장되면 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색한다.
	- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
	- 리프 노드가 꽉 찬다면 리프 노드를 분리해야 하는데, 이는 상위 브랜치 노드까지 처리 범위가 넓어진다.
		- 이 작업으로 인해 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.
- **인덱스 키 삭제**
	- 삭제한 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 한다.
	- 마킹할 때 디스크 쓰기 작업을 하기 때문에 이 작업도 디스크 I/O가 필요한 작업이다.
- **인덱스 키 변경**
	- 인덱스 키 값이 리프 노드의 위치를 결정하기 때문에 먼저 키 값을 삭제한 후, 다시 새로운 킬 값을 추가하는 형태로 처리한다.
	
-> InnoDB 스토리지 엔진을 사용하는 테이블은 이 세 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다. (다만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가 및 삭제한다.)

- **인덱스 키 검색**
	- 데이터를 추가, 삭제, 변경하는 작업은 다 느려지지만 검색 작업만 빨라진다.
		- 하지만 UPDATE, DELETE 시 SELECT를 먼저 해야하는 경우는 빨라질 수 있다.
	- 검색 사용 조건
		- 검색 조건이 100% 일치하는 경우
		- 값의 앞부분만 일치하는 경우
		- 부등호 비교 조건에서도 사용할 수 있지만 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없음
		- 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색을 사용할 수 없음
			- 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없음
	- InnoDB에서 레코드 잠금은 인덱스를 잠근다. 
		- 인덱스 설계를 잘못하면 많은 레코드를 잠글 수 있기 때문에 주의해야 한다.
### B-Tree 인덱스 사용에 영향을 미치는 요소
- **인덱스 키 값의 크기**
	- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
	- 인덱스도 페이지 단위로 관리되며 루트, 브랜치, 리프 노드를 구분한 기준이 페이지 단위이다.
	- 인덱스의 키 값이 커질 수록 한 페이지에 담을 수 있는 인덱스 키의 수가 감소한다. 따라서 검색하기 위해 여러 페이지를 읽을 가능성이 높아지기 때문에 인덱스 키 값의 크기가 커질수록 성능이 좋지 않다.
	- 인덱스의 키 값이 커지는 것은 인덱스의 크기가 커지는 것을 의미하는데, 인덱스를 캐시해두는 버퍼 풀은 크기가 제한적이기 때문에 캐시할 수 있는 양이 줄어들어 성능이 안좋아질 수 있다.
- **B-Tree 깊이**
	- 인덱스의 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져 디스크 읽기가 더 많이 필요하게 된다.
- **선택도**
	- 선택도는 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 
		- 전체 인덱스 키 값은 100개 인데, 그 중 유니크한 값의 수가 10개라면 선택도는 10이다.
	- 선택도가 높을 수록 성능이 좋다.
		- 정렬이나 그루핑 작업은 선택도가 낮더라도 성능이 좋을 수 있음
	- 총 10000개의 데이터가 있을 때, 첫 번째 경우는, A 컬럼의 유니크한 값이 1000개 있는 경우이다. 이때 해당 값을 인덱스를 통해 검색했을 때, 평균 10개의 데이터만 검색하면 된다. 반면에 두 번째 경우는, A 컬럼의 유니크한 값이 10개 있는 경우이다. 이때 해당 값을 인덱스를 통해 검색했을 때, 평균 1000개의 데이터를 검색해야 한다. 따라서 중복 값이 적을 수록 인덱스 성능이 좋아진다.
- **읽어야 하는 레코드의 건수**
	- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
		- 일반적으로 4~5배 더 비효율적이라 판다
	- 따라서 인덱스를 통해 데이터를 읽는 건수가, 테이블의 전체 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 읽어서 걸러내는 것이 더 효율적이라 본다.
### B-Tree 인덱스를 통한 데이터 읽기
- **인덱스 레인지 스캔**
	- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
	- 범위의 시작 리프 노드에 도달하면 범위 순서대로 리프 노드의 레코드만 읽으면 된다. 
	- 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이때는 레코드 한 건 단위로 랜덤 I/O가 한 번씩 일어난다.
		- 따라서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.
		- 커버링 인덱스인 경우 데이터 파일에서 읽어오는 과정은 필요 없이 인덱스에서 가져온다.
- **인덱스 풀 스캔**
	- 인덱스를 처음부터 끝까지 모두 읽는 방식
	- 쿼리 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용된다.
		- 인덱스는 (A, B, C)지만 조건절은 B 칼럼으로 시작되는 경우
	- 쿼리가 커버링 인덱스로 처리될 수 있는 경우 이 방식을 사용한다.
		- 커버링 인덱스가 아니라면 이 방식을 사용하지 않는다.
- **루스 인덱스 스캔**
	- 인덱스를 듬성 듬성 읽는 방식
	- 인덱스 레인지와 비슷하게 동작하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
	- 일반적으로 `GROUP BY`, `MAX()`, `MIN()` 함수를 처리하는데 사용한다.
- **인덱스 스킵 스캔**
	- 복합 인덱스에서 인덱스의 뒤에 있는 컬럼만 `WHERE` 절에 사용했을 때에도 인덱스를 사용하는 방식
		- (`gender`, `birth_date`) 복합 인덱스가 있을 때, `SELECT ... WHERE birth_date >= '2021-03-11';` 쿼리에도 인덱스를 사용하도록 한다.
	- 방식은 인덱스의 앞의 컬럼에 유니크한 값을 조건절에 추가하여 쿼리하는 방식을 사용하여 인덱스 레인지 스캔을 유도한다.
		-  `SELECT ... WHERE birth_date >= '2021-03-11';` 이 쿼리를 다음 두 개의 쿼리로 나누어 처리한다.
			- `SELECT ... WHERE gender = 'M' AND birth_date >= '2021-03-11'`
			- `SELECT ... WHERE gender = 'F' AND birth_date >= '2021-03-11'`
	- MySQL 8.0부터 지원한다.
	- **제약**
		- `WHERE` 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 한다.
		- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 한다.(커버링 인덱스)
### 다중 칼럼 인덱스
![](https://i.imgur.com/niTHoUl.png)
- 2개 이상의 칼럼을 포함하는 인덱스
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼이 같은 경우에만 정렬된다.
### B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스의 정렬
	- 인덱스를 생성할 때 오름차순, 내림차순을 지정해서 생성할 수 있다.
		- `CREATE INDEX ... ON ... (colum1 ASC, column2 DESC)`
	- 인덱스 스캔 방향
		- 오름차순으로 정렬되어 있는 인덱스의 컬럼의 최댓값을 구하는 쿼리가 있다면, 인덱스를 역순으로 탐색하여 가장 처음 데이터를 반환한다.
		- 즉, 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만, 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순(정순으로 읽기) 또는 내림차순(역순으로 읽기) 정렬 효과를 얻을 수 있다.
	- 내림차순 인덱스
		- 데이터를 역순으로 읽는 것은 정순으로 읽는 것보다 더 비효율적이다.
			- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이기 때문
			- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이기 때문
### B-Tree 인덱스의 가용성과 효율성
- **비교 조건의 종류와 효율성**
	- **조건**
		- 인덱스 A : (dept_no, emp_no), 인덱스 B : (emp_no, dept_no)
		- 쿼리 : `SELECT * FROM dept_emp WHERE dept_no='d0' AND emp_no >= 10;`
	- **과정**
		- 인덱스 A를 사용했을 때는 `dept_no`가 정렬되어 있기 때문에 `dept_no`가 `d0`이고, `emp_no`가 10보다 크거나 같은 시작점의 레코드를 찾는다. 그리고 해당 레코드를 기준으로 `dept_no`가 `d0`이 아닌 레코드까지 순서대로 쭉 읽어나가기만 하면 된다.
		- 인덱스 B를 사용했을 때는 `emp_no`가 10보다 크거나 같은 구간을 찾고, 해당 구간부터 마지막 레코드까지 쭉 읽어나가면서 `dept_no`가 `d0`인 레코드만 읽는다. 
	- **결과**
		- 인덱스 A를 사용했을 때는 꼭 필요한 데이터만 조회할 수 있다.
			- `emp_no`, `dept_no` 모두 검색 범위를 좁히는데 도움을 줌
		- 인덱스 B는 필요하지 않은 데이터까지 읽고 버리는 과정이 필요하다. (필터링)
			- `emp_no`는 작업 범위를 좁히는데 도움을 주지만, `dept_no`는 단지 검색 조건에 불과
- **인덱스의 가용성**
	- 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있다.
		- 예를 들어, `first_name`을 인덱스로 사용하는 경우 'A a Kong' 이라는 값은 'A b Kong'이라는 값보다 앞쪽에 정렬되어 있다. (사전 순)
		- 따라서 이 경우 `SELECT * FROM x WHERE first_name LIKE '%Kong'`과 같이 쿼리를 날리면 왼쪽 부분은 고정되어 있지 않기 때문에 인덱스 레인지 스캔을 사용할 수 없다. 
- **가용성과 효율성 판단**
	- **단일 컬럼**
		- B-Tree 인덱스 특성상 다음 조건에서는 사용할 수 없다. (탐색 범위를 줄이는 데에 사용할 수 없다는 뜻)
			- `NOT-EQUAL`로 비교된 경우 (`...NOT IN (1,2,3)`, `... IS NOT NULL`)
			- 참고로, MySQL에서는 `NULL`값도 인덱스에 포함된다. 따라서 다음 조건은 범위 결정 조건으로 인덱스를 사용한다.
				- `..WHERE column IS NULL`
		- `LIKE '%??'` 형태로 문자열 패턴이 비교된 경우
		- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
			- `..WHERE SUBSTRING(column, 1, 1) = 'X'`
		- `NOT-DETERMINISTIC` 속성의 스토어드 함수가 비교 조건에 사용된 경우
			- `..WHERE column = deterministic_function()`
		- 데이터 타입이 서로 다른 비교
			- `..WHERE char_column = 10`
		- 문자열 데이터 타입의 콜레이션이 다른 경우
			- `.. WHERE utf8_bin_char_column = euckr_bin_char_column`
	- **다중 컬럼**
		- **인덱스를 사용하여 범위를 좁힐 수 없는 경우**
			- 인덱스를 구성하는 컬럼 중 앞의 컬럼에 대한 조건이 없는 경우
			- 인덱스의 앞의 컬럼의 비교 조건이 인덱스의 사용 불가 조건 중 하나인 경우
		- **인덱스를 사용하여 범위를 좁힐 수 있는 경우**
			1. `column_1 ~ column_(i-1)` 칼럼까지 동등 비교 형태("=", "IN")로 비교하는 경우
			2. 1을 만족하면서 `column_i` 칼럼에 대해 다음 연산자 중 하나로 비교하는 경우
				- 동등 비교
				-  부등호
				- `LIKE`로 좌측 일치


![](https://i.imgur.com/zyHrlyb.png)
![](https://i.imgur.com/N8d920Z.png)

## 전문 검색 인덱스
- 전문 검색 인덱스
	- 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘
### 인덱스 알고리즘
- 전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다.
- **어근 분석 알고리즘**
	- 전문 검색 인덱스는 다음 두 가지 과정을 거쳐 인덱싱 작업을 한다.
		- **불용어 처리**
			- 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 방법
			- 불용어는 MySQL 서버에 내장되어 있다.
		- **어근 분석**
			- 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
			- MySQL에서는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 사용하여 이 작업을 할 수 있다. 
- **n-gram 알고리즘**
	- MeCab을 사용하는 것보다 더 간단한 방법으로 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘이다.
	- 본문을 몇 글자씩 잘라서 인덱싱하는 방법
	- n-gram의 n은 인덱싱할 키워드의 최소 글자 수를 의미한다. (보통 2를 사용)
	- 예를 들어, `To be or not to be. That is the question`를 인덱싱 한다면 단어 별로 쪼개서 각 단어 별로 2글자씩 중첩해서 토큰으로 분리하고 각 토큰을 인덱스에 저장한다.
		- `To` -> `To`
		- `not` -> `no`, `ot`
		- `That` -> `Th`, `ha`, `at`
	- 각 토큰들에 대해 불용어를 걸러내는 작업을 수행한다.
	- 각 토큰을 B-Tree 인덱스에 저장한다. 
### 불용어 변경 및 삭제
- 불용어 처리를 완전히 무시하거나 서버에 내장된 불용어 대신 사용자가 불용어를 직접 등록할 수 있는 방법을 제공한다.
### 전문 검색 인덱스의 가용성
- **전문 검색 인덱스 사용을 위한 조건(두 조건을 모두 만족)**
	- 쿼리 문장이 전문 검색을 위한 문법을 사용한다.
		- `MATCH ... AGAINST ...`
	- 테이블의 전문 검색 대상 칼럼에 대해서 전문 인덱스를 보유한다.
		- `FULLTEXT KEY ... WITH PARSER ngram`

## 멀티 밸류 인덱스
- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
	- 정규화에 위배
	- JSON 타입의 등장으로 탄생

## 클러스터링 인덱스
![](https://i.imgur.com/RrP3lIv.png)

클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다.
### 클러스터링 인덱스
- 테이블의 프라이머리 키에 대해서만 적용되는 인덱스
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다.
	- 프라이머리 키 값이 바뀌면 레코드의 물리적인 위치가 변경됨
- 리프 노드에는 레코드의 모든 값이 저장되어 있다.
- 프라이머리 키가 없는 경우 InnoDB 스토리지 엔진이 프라이머리 키를 대체할 칼럼을 선택한다.
	1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
	2. `NOT NULL` 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
	3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택
### 세컨더리 인덱스에 미치는 영향
- 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.
### 클러스터링 인덱스의 장단점
- **장점**
	- 프라이머리 키를 검색 조건으로 사용했을 때 성능이 매우 빠름
	- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우(커버링 인덱스)가 많음
- **단점**
	- 세컨더리 인덱스는 리프 노드에 클러스터링 키를 갖기 때문에 클러스터링 키의 값이 클수록 전체적인 인덱스의 크기가 커짐
	- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키를 한 번 더 거쳐야 하기 때문에 성능이 느림(커버링 인덱스가 아닌 경우)
	- 데이터를 삽입할 때 프라이머리 키에 의해 레코드의 저장 위치가 결졍되기 때문에 처리 성능이 느림
	- 프라이머리 키를 변경할 때 레코드를 `DELETE` + `INSERT` 해야하기 때문에 처리 성능이 느림
### 클러스터링 테이블 사용 시 주의사항
- **클러스터링 인덱스 키의 크기**
	- 세컨더리 인덱스는 클러스터링 키를 포함하기 때문에 클러스터링 키가 커질 수록 전체적인 인덱스의 크기가 커진다.
- **프라이머리 키는 반드시 명시할 것**
	- 프라이머리 키를 명시적으로 생성하지 않으면 내부적으로 AUTO_INCREMENT와 같이 증가하는 값을 가진 칼럼을 추가하는데, 사용자가 이 칼럼에 접근할 수 없다.
		- 따라서 프라이머리 키를 통해 데이터 접근을 가능하게 하려면 명시적으로 생성하는게 좋다.
	- ROW 기반 복제나 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 하는 정상적인 복제 성능을 보장하기도 하므로 프라이머리 키를 꼭 생성해야 한다.

## 유니크 인덱스
- 유니크 인덱스는 사실상 제약조건이다. 
- 유니크 제약조건을 적용하면 인덱스가 자동으로 생성된다.
### 유니크 인덱스와 세컨더리 인덱스 비교
- **인덱스 읽기**
	- 읽기 성능은 거의 같다고 보면 된다.
- **인덱스 쓰기**
	- 유니크 인덱스에서는 중복된 값이 있는지 체크하는 과정이 추가되므로 더 느리다.
	- 유니크 인덱스에서 중복된 값을 체크할 때 읽기 잠금을 사용하고 쓰기를 할 때는 쓰기 잠금을 사용한다.
		- 이 과정에서 데드락이 빈번히 발생한다.
	- 유니크 인덱스는 중복 체크를 해야하기 때문에 체인지 버퍼를 사용하지 못한다.
		- 이 때문에 쓰기 성능이 더 느림
### 유니크 인덱스 사용 시 주의사항
- 유니크 인덱스는 일반 인덱스와 같은 역할을 하기 때문에 중복해서 생성하면 안된다.
- 유일성이 보장되는 컬럼에 대해 생성하자

## 외래키
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
- 테이블의 변경이 발생하는 경우에만 잠금 대기가 발생한다.
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 대기를 발생시키지 않는다.
### 자식 테이블의 변경이 대기하는 경우
`parent` 테이블과 `child` 테이블이 있다고 하자, 이때 `child` 테이블의 `pid`는 `parent` 테이블의 `id`를 외래키로 참조하고 있다. 또한 외래키 제약 조건에 `ON DELETE CASCADE` 조건도 붙어있다.
![](https://i.imgur.com/lgE7yzQ.png)
이때, 위 과정을 보면 커넥션 1에서 `id`를 2로 변경한다. 즉 해당 레코드에 쓰기 잠금이 걸린다. 그 다음 커넥션 1이 종료되지 않은 상태에서 커넥션 2에서 현재 쓰기 잠금이 걸려있는(커넥션 1로 인해) 레코드와 연관되어 있는 레코드의 `pid`를 2로 변경하고자 한다. 이때는 커넥션 2의 작업이 커넥션 1의 작업이 종료될 때까지 기다린다.
-> 즉, 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 해당 레코드에 쓰기 잠금이 걸려있으면 해당 쓰기 잠금이 해제될 때까지 기다린다.

반면에, 자식 테이블의 외래키가 아닌 칼럼의 변경은 상관없다.
### 부모 테이블의 변경 작업이 대기하는 경우
![](https://i.imgur.com/hEYcha9.png)
커넥션 1에서 부모 테이블의 `id`가 1인 레코드를 참조하는 레코드의 칼럼을 변경한다. 이때 쓰기 잠금이 걸리고  그리고 커넥션 2에서 커넥션 1에서 변경하는 레코드가 참조하는 레코드를 삭제한다. 이 경우 커넥션 1의 쓰기 잠금이 해제될 때까지 기다려야 한다. 왜냐하면 `ON DELETE CASCADE` 옵션으로 인해 부모 테이블의 레코드가 삭제되면 참조하고 있는 자식 테이블의 레코드도 삭제해줘야 하기 때문이다.

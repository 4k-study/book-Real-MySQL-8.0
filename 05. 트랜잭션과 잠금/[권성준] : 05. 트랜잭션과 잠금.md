## 5.1 트랜잭션

### 5.1.1 MySQL에서의 트랜잭션

- MyISAM 과 MEMORY 스토리지 엔진은 트랜잭션 지원X
    - 부분 업데이트 발생하여 정합성에 문제 생길 수 있음
- InnoDB 는 트랜잭션을 지원함

### 5.1.2 주의사항

게시글 저장 플로우를 보며 주의사항을 살펴보자

```
1. 처리 시작
	→ DB 커넥션 시작
	→ 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장   
	→ 트랜잭션 종료 (COMMIT)
  → DB 커넥션 반납 
10. 처리 완료
```

- 트랜잭션의 범위를 최소화하는 것이 좋음
    - DB 커넥션, DB가 필요 없는 검증 작업들은 트랜잭션에서 제외하자
        - 커넥션에 갯수 제한이 있으므로 트랜잭션이 길어지면 대기 시간이 생길 수 있음
- 메일, FTP 파일 전송 또는 네트워크를 통한 서버 간 통신은 트랜잭션에서 제거하는 것이 좋음
    - 서버 간 통신 실패 시 DB 서버에도 영향을 줄 수 있음
- 위 플로우에서 추가적인 트랜잭션 관리 사항
    - 함께 실행되야 할 5, 6번 트랜잭션은 묶기
    - 7번은 단순 조회이므로 트랜잭션을 사용하지 않아도 무방함
    - 9번은 성격이 다르므로 별도 트랜잭션으로 분리

수정한 게시물 저장 플로우를 살펴보자

```
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
	→ DB 커넥션 시작
	→ 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
	→ 트랜잭션 종료 (COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
	-> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장   
	→ 트랜잭션 종료 (COMMIT)
  → DB 커넥션 반납 
10. 처리 완료
```

## 5.2 MySQL 엔진의 잠금

- 스토리지 엔진 레벨, MySQL 엔진 레벨로 나뉨
    - MySQL 엔진 레벨
        - 스토리지 엔진을 제외한 나머지 전부가 해당
        - 모든 스토리지 엔진에 영향을 줌
        - ex) 테이블 락, 메타데이터 락, 네임드 락
    - 스토리지 엔진 레벨
        - 스토리지 엔진 간에는 영향을 주지 않음

### 5.2.1 글로벌 락

- `FLUSH TABLES WITH READ LOCK` 명령어로 획득
- 가장 큰 범위 (MySQL 서버 전체)
- 모든 DDL, DML (SELECT 제외) 을 대기시킴
- InnoDB 는 트랜잭션을 지원하므로 모든 데이터 작업을 대기시킬 필요가 없음. 이로 인해 가벼운 글로벌 락의 필요성이 대두됨.
    - 백업 락 등장
        - 일반 테이블 데이터는 변경 가능
        - 백업 시에 복제를 락으로 막지는 않음. 다만, 백업 성공을 위해 테이블 스키마, 인증 관련 정보 변경을 허용하지 않음

### 5.2.2 테이블 락

- 개별 테이블 단위로 설정
- MyISAM 이나 MEMORY 에서는 데이터 변경 시 묵시적으로 잠금됨
- InnoDB 는 레코드 기반 락을 제공하므로 데이터 변경 시 발생 X
    - DDL 시에는 발생함

### 5.2.3 네임드 락

- 임의의 이름(문자열) 에 대해 잠금을 설정함
- 잠금 대상이 테이블/레코드/객체가 아님
- 많은 레코드를 복잡하게 변경하는 경우 데드락 방지에 유용하게 사용 가능

### 5.2.4 메타데이터 락

- DB 객체의 이름이나 구조 변경 시 획득하는 락
- 명시적으로는 획득할 수 없음. 자동으로 획득됨.

## 5.3 InnoDB 스토리지 엔진 잠금

- 레코드 기반 잠금으로 뛰어난 동시성을 가짐
- 이원화된 잠금으로 MySQL 명령으로 접근하기 어려웠으나 버전이 향상되며 점차 해결됨

### 5.3.1 InnoDB 스토리지 엔진의 잠금

- 잠금 정보가 매우 작은 공간으로 관리되어 락 에스컬레이션이 거의 일어나지 않음
- 레코드와 레코드 사이 간격을 잠그는 갭 락 존재함

**레코드 락**

- 레코드 자체만 잠금
- InnoDB의 경우 레코드 자체를 잠그는 것이 아닌 레코드의 인덱스를 잠금

**갭 락**

- 레코드 자체가 아닌 레코드와 인접한 레코드 사이의 간격을 잠금
- 레코드 간 사이에 새로운 레코드 생성을 방지함

**넥스트 키 락**

- 레코드 락 + 갭 락의 형태
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버와 결과가 동일함을 보장하는 것이 목적
- 넥스트 키 락으로 데드락이 발생하는 경우가 빈번함.
    - 바이너리 로그 포맷을 ROW 로 바꿔 넥스트 키 락과 갭 락을 줄이자
        - 8.0 이상 버전에서는 ROW 가 기본 값임

**자동 증가 락**

- AUTO_INCREMENT 락임 (테이블 수준)
- INSERT, REPLACE 같은 생성 쿼리에만 적용됨
- AUTO_INCREMENT 값을 가져오는 순간 락이 걸렸다 즉시 해제됨
- 5.1 버전 이상부터 INSERT 되는 갯수를 예측 가능할 시 래치(뮤텍스)를 사용하여 빠르게 처리함

### 5.3.2 인덱스와 잠금

- InnoDB 는 잠금 시 인덱스를 잠금함
- 성이 ‘권’ 인 사원이 200명, 성이 ‘권’ 이면서 이름이 ‘성준’ 인 사원이 1명이라고 하자. 또한, 테이블에 총 레코드 수는 10만개, 인덱스는 성 칼럼에만 적용되어 있다고 하자.
    - 이때 ‘권성준’ 사원의 이름을 update 하면 200개 레코드의 인덱스에 락이 걸림
    - 만약 성 칼럼에 인덱스가 없다고 가정하면, 테이블의 모든 레코드 10만개가 락이 걸림

### 5.3.3 레코드 수준의 잠금 확인 및 해제

- 버전 별로 레코드 잠금 확인하는 법이 발전 중
- 강제로 잠금 해제를 하려면 `KILL` 명령어 사용하면 됨

## 5.4 MySQL의 격리 수준

- 격리 수준이란 서로 다른 트랜잭션끼리 변경하는 데이터를 볼 수 있는지 여부를 결정하는 것임
- DIRTY READ, NON-REPEATABLE READ, PHANTOM READ 가 격리 수준에 따라 발생 가능함
- 일반적인 온라인 서비스에서는 READ COMMITTED 나 REAPEATABLE READ 수준을 사용함
- MySQL 은 REAPEATABLE READ 을 주로 사용함

### 5.4.1 READ UNCOMMITTED

- 각 트랜잭션의 변경 내용이 커밋/롤백과 관계 없이 보임
- 더티 리드가 허용되므로 정합성에 문제가 많음
- READ COMMITTED 이상을 사용할 것을 추천함

### 5.4.2 READ COMMITTED

- 온라인 서비스에서 가장 많이 선택
- 더티 리드 발생 안함
- NON-REPEATABLE READ 발생함
    - 일반적인 웹 서비스에서는 괜찮지만 한 트랜잭션에서 여러 번 읽고 변경되는 금융과 같은 서비스에서는 문제가 될 수 있음
- READ COMMITTED 수준에서는 SELECT 쿼리가 트랜잭션 밖에서 실행되어도 별 차이 없음

### 5.4.3 REPEATABLE READ

- InnoDB 에서 기본으로 사용
- NON-REAPEATABLE READ 발생 안함
- SELECT 시 트랜잭션 범위 안에서만 동작함
- MVCC 를 활용하여 한 트랜잭션 내에서 같은 값을 보여줌
    - InnoDB 트랜잭션은 고유 번호를 가지고, 언두 영역에는 트랜잭션 고유 번호가 포함됨
    - 특정 트랜잭션 번호 이전의 언두 로그를 이용함
- PHANTOM READ 발생
    - InnoDB 의 경우 발생 안함
        - 검색한 범위 내에 갭 락과 넥스트 키 락이 적용되어 추가적인 INSERT 를 방지하기 때문

### 5.4.4 SERIALIZABLE

- 가장 엄격한 격리 수준. 동시성 처리 수준은 가장 떨어짐.
- 읽기 작업도 공유 락을 획득해야 함. 즉, 한 트랙잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 접근할 수 없음.
- PHANTOM READ 발생 안함

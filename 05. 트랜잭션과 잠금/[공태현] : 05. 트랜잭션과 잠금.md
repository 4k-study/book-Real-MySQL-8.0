## 트랜잭션
트랜잭션은 **작업의 완전성을 보장**해 주는 것이다. 논리적인 작업 셋을 모두 완벽하기 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.

### MySQL에서의 트랜잭션
트랜잭션은 하나의 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다. InnoDB는 트랜잭션을 지원하지만 Memory나 MyISAM은 트랜잭션을 지원하지 않는다. 따라서 MyISAM은 트랜잭션 작업 내용 중 일부만 저장되는 부분 업데이트 현상이 나타나며 이는 데이터 정합성에 문제를 일으킨다. 
### 주의 사항
트랜잭션은 **범위를 최소화하는 것이 좋다.** 

다음 예를 보자

![](https://i.imgur.com/2hUPz5L.png)
<br>
![](https://i.imgur.com/3V0qvB6.png)

위 순서대로 처리되는 작업은 몇 가지 문제점이 존재한다.

첫 번째로, **트랜잭션 시작이 너무 빠르다**는 것이다. 위 작업은 트랜잭션을 커넥션을 생성한 이후부터 적용한 것을 볼 수 있다. 하지만 실제로 트랜잭션이 필요한 작업은 5번 작업이다. 

두 번째로, **8번 작업(원격 서버와 통신하는 작업)을 트랜잭션에 포함시켰다**는 점이다. 알림 메일을 발송하는 작업은 네트워크를 통해 원격 서버와 통신하는 작업이기 때문에 원격 서버와 통신할 수 없는 상황이 발생한다면 웹 서버 뿐만 아니라 DBMS 서버까지 위험해지는 상황이 발생할 것이다. (트랜잭션이 원격 서버와 연결이 안돼서 길어진다.)

세 번째로, 결과적으로 **트랜잭션이 너무 길다**는 것이다. 트랜잭션에 포함시키지 않아도 되는 작업들까지 트랜잭션에 포함되어 있다는 문제점이 있다.

이를 다음과 같이 개선할 수 있다.

![](https://i.imgur.com/qlIAcSV.png)

하나의 트랜잭션으로 묶여야 하는 5 ~ 6번 작업을 하나의 트랜잭션으로 가져가고 9번 작업을 하나의 트랜잭션으로 가져감으로써 트랜잭션 범위를 최소화한다. 중요한 점은 **원격 서버와 통신하는 작업을 트랜잭션에 포함시켜서는 안되고 트랜잭션은 최대한 짧게 가져가는 것이 좋다는 것**이다. 

## MySQL 엔진의 잠금
MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨의 잠금과 MySQL 엔진 레벨의 잠금으로 나눌 수 있다. MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 끼치지만, 스토리지 엔진의 잠금은 스토리지 엔진 간에 서로 영향을 끼치지 않는다. 
### 글로벌 락
MySQL에서 제공하는 락의 범위 중 가장 크며 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다. 글로벌 락을 실행하면, **`SELECT`문을 제외한 대부분의 명령이 실행되지 않는다.** 서버 전체에 영향을 미치며 `mysqldump`같은 명령을 했을 때 내부적으로 글로벌 락이 걸리기도 한다.

글로벌 락 명령을 실행하면 MySQL 서버에 존재하는 **모든 테이블을 닫고 잠금을 건다.** 글로벌 락 명령은 읽기 잠금을 걸기 전에 `FLUSH`를 해야하기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료되어야 실행될 수 있다. 따라서 장기간 실행되는 `SELECT` 쿼리가 있다면 해당 쿼리가 끝날 때까지 글로벌 락이 실행되지 않고 대기하기 때문에 모든 서버에 대한 DML이 오랫동안 실행되지 않을 수 있다. 따라서 웹 서비스용으로 사용되는 MySQL 서버에 사용하지 않는 것이 좋다.

백업 락은 더 가벼운 형태의 글로벌 락이다. InnoDB는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 수 없다. 따라서 백업 락이 등장하게 된 것이며, 백업 락을 걸면 글로벌 락과 다르게 일반적인 테이블의 데이터 변경은 허용된다. 
### 테이블 락 
**개별 테이블 단위로 설정되는 잠금**이며, `LOCK TABLES table_name [READ | WRITE]` 명령으로 테이블 락을 획득할 수 있다. Memory나 MyISAM 엔진에서는 테이블의 데이터를 변경하는 쿼리를 실행하면 묵시적으로 테이블 락이 걸리고, InnoDB에서는 스키마를 변경하는 DDL에만 테이블 락이 걸린다.
### 네임드 락
**임의의 문자열에 대해 거는 잠금**이며, `GET_LOCK()` 함수를 이용해 락을 걸 수 있다. 잠금의 대상이 테이블이나 레코드와 같은 데이터베이스 객체가 아니라 단순히 사용자가 지정한 문자열에 대해 획득하고 락이다. 
### 메타데이터 락
**데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금**이다. 명시적으로 획득하는 것이 아니고 `RENAME TABLE tab_a TO tab_b`같이 테이블의 이름을 변경하는 경우 자동으로 획득한다. 

## InnoDB 스토리지 엔진 잠금

![](https://i.imgur.com/OtMSuLE.png)

### 레코드 락
**레코드를 잠그는 락**을 의미한다. 하지만 레코드 자체를 잠그는 것은 아니고 인덱스의 레코드를 잠근다. 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭락을 걸지 않고 레코드 락만 건다.
### 갭 락
레코드 자체가 아니라 **레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락**을 의미한다. 갭 락의 역할은 레코드와 레코드 사이에 새로운 레코드가 `INSERT` 되는 것을 방지한다. 
### 넥스트 키 락
**레코드 락과 갭 락을 합쳐놓은 형태**이다. 
### 자동 증가 락
**`AUTO_INCREMENT`를 사용하여 자동으로 증가하는 값을 가져야할 때 걸리는 락**이다. 자동 증가 락은 테이블 당 하나만 존재하기 때문에 여러 레코드가 동시에 `INSERT` 되어도 서로 다른 값을 가질 수 있도록 **테이블 수준의 락**을 건다. 

자동 증가 락은 MySQL 5.1 이상부터는 `innodb_autoinc_lock_mode`라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.
- `innodb_autoinc_lock_mod = 0`
	- 모든 `INSERT` 문장은 자동 증가 락을 사용한다.
- `innodb_autoinc_lock_mod = 1`
	- `INSERT`되는 레코드의 수를 정확히 예측할 수 있을 때는 자동 증가 락 대신 더 빠른 뮤택스를 이용해 처리한다.
	- `INSERT`되는 레코드의 수를 에측할 수 없을 때는 자동 증가 락을 사용한다. 
	- 예측할 수 없어 자동 증가 락을 사용하는 경우, 한 번에 대량의 자동 증가 값을 할당 받아서 사용하기 때문에 저장되는 레코드가 연속된 값을 갖지만, 레코드를 다 저장하고 남은 자동 증가 값이 있다면 해당 값들은 폐기되기 때문에 이후 저장되는 값은 연속되지 않은 값을 가질 수 있다. 
- `innodb_autoinc_lock_mod = 2`
	- 절대 자동 증가 락을 걸지 않고 뮤택스를 사용한다.
	- 하나의 `INSERT` 문으로 저장되는 레코드여도 서로 연속되지 않은 값을 가질 수 있다. 
	- 하나의 커넥션에서 `INSERT` 문을 수행 중이여도 다른 커넥션에서 `INSERT` 문을 수행할 수 있기 때문에 동시 처리 성능이 뛰어나다. 

## 인덱스와 잠금
InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락을 걸어야 한다.

다음 예제를 보자.

![](https://i.imgur.com/YhKhAIH.png)

위 `UPDATE` 문은 단 한 건의 레코드를 업데이트한다. 하지만 `first_name`을 검색할 때, 인덱스를 사용하게 되고, 조건에 해당되는 **인덱스에 모두 락을 걸게된다.** 위 예제에서 `first_name`이 `Georgi`인 인덱스의 레코드는 총 253개이기 때문에 253건의 레코드에 모두 락을 건다. 

위 예제에서 만약 `first_name`에 인덱스가 설정되어 있지 않다면 모든 레코드에 락을 걸어야 하기 때문에 동시 처리 성능이 떨어질 수 있다. 따라서 인덱스 설계는 매우 중요하다.

![](https://i.imgur.com/e6skCEB.png)

## 레코드 수준의 잠금 확인 및 해제
다음 명령어를 통해 스레드의 대기 큐를 확인할 수 있다.
```sql
SELECT r.trx_id waiting_trx_id, r.trx_mysql_thread_id waiting_thread, 
	   r.trx_query waiting_query, b.trx_id blocking_trx_id, 
	   b.trx_mysql_thread_id blocking_thread, b.trx_query blocking_query 
FROM performance_schema.data_lock_waits w 
	INNER JOIN information_schema.innodb_trx b 
		ON b.trx_id =w.blocking_engine_transaction_id 
	INNER JOIN information_schema.innodb_trx r 
		ON r.trx_id =w.requesting_engine_transaction_id;
```
![](https://i.imgur.com/Ta2zrPN.png)

더 상세히 확인하고 싶다면 다음 명령어를 사용하면 된다.
```sql
> SELECT *FROM performance_schema.data_locks\G
```
![](https://i.imgur.com/MxLqWOB.png)

## MySQL의 격리 수준
트랜잭션의 격리 수준이란, 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
### READ UNCOMMITTED

![](https://i.imgur.com/8v9q57I.png)

**한 트랜잭션에서 변경된 데이터가 트랜잭션의 커밋이나 롤백 여부와 상관 없이 다른 트랜잭션에서 변경된 내용이 조회**되는 격리 수준이다. 만약 데이터를 변경한 트랜잭션이 롤백된다면, 변경된 데이터를 조회한 다른 트랜잭션은 잘못된 데이터를 조회한 것이다. 이를 더티 리드(Dirty Read)라고 하며, 이러한 문제 때문에 권장하지 않는 격리 수준이다.
### READ COMMITTED

![](https://i.imgur.com/XtHCRIz.png)

오라클 DB의 기본 격리 수준으로, **트랜잭션에 의해 커밋이 완료된 데이터의 변경사항만 조회가 가능**한 격리 수준이다. 트랜잭션에서 데이터를 변경했을 때, 해당 데이터의 변경되기 전 정보가 언두 로그에 남게되는데, 다른 트랜잭션에서 해당 데이터를 조회하면 언두 로그에 저장된 데이터를 조회한다. 

![](https://i.imgur.com/FXa307o.png)

READ COMMITTED 격리 수준에서는 **NON-REPEATABLE READ 문제가** 발생할 수 있다. 특정 트랜잭션에서 조회한 데이터에 대하여 다른 트랜잭션이 해당 데이터를 변경하고 커밋하면 처음 트랜잭션에서 다시 해당 데이터를 조회했을 때 이전과 다른 데이터가 조회될 수 있다. 이는 한 트랜잭션에서 같은 `SELECT` 쿼리를 실행했을 때, 항상 같은 결과를 가져와야 한다는 "REPEATABLE READ" 정합성에 어긋나는 것이다.
### REPEATABLE READ

![](https://i.imgur.com/iR51xnb.png)

**MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준**으로, **한 트랜잭션에서 조회한 데이터는 다른 트랜잭션의 커밋, 롤백 여부와 상관없이 항상 같은 데이터가 조회**되는 격리 수준이다. READ COMMITTED와 마찬가지로 MVCC를 사용하여 일관된 읽기를 제공한다. 하지만 차이점은, 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.

모든 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트래잭션의 번호가 포함되어 있다. REPEATABLE READ는 **일관된 읽기를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다**(원래는 InnoDB 엔진이 자동으로 삭제함). 한 트랜잭션에서 특정 데이터를 조회할 때, 자신보다 낮은 번호를 가진 트랜잭션(먼저 생성된 트랜잭션)이 변경시킨 데이터만 조회함으로써 일관된 읽기를 제공할 수 있다(낮은 번호라고 모두 조회하는 것은 아니고, 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터를 조회한다. -> 따라서 번호가 더 빠른 트랜잭션이 데이터를 변경하고 커밋했다 해서 더 느린 트랜잭션이 해당 데이터를 조회했을 때 바뀐 값이 조회되지 않는다.).

![](https://i.imgur.com/yXr5kdL.png)

일반적으로 REPEATABLE READ에서도 위와 같은 **팬텀 리드 현상**이 발생할 수 있다. 팬텀 리드란, 한 트랜잭션에서 여러 데이터를 조회했을 때, 다른 트랜잭션에서 삽입한, 새로운 데이터가 해당 범위에 포함됨으로써, 두 번째 조회했을 때 새로운 데이터가 추가로 조회되는 현상을 말한다.

위 예시를 보면, 번호가 10인 트랜잭션이 처음 `employees` 테이블에서 `emp_no`가 500000 이상인 값을 검색했을 때, `Lara` 데이터만 조회되었다. 하지만 번호가 12인 트랜잭션이 `emp_no`가 500001인 데이터를 넣고 커밋을 한 뒤 다시 번호가 10인 트랜잭션이 `FOR UPDATE`로 `emp_no`가 500000 이상인 값을 조회하면 `emp_no`가 500001인, 새롭게 삽입된 데이터가 함께 조회된다. 

`SELECT...FOR UPDATE` 쿼리는 `SELECT`하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. 따라서 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 된다. 따라서 MVCC가 동작하지 않아 팬텀 리드가 발생하게 되는 것이다.

참고로, `FOR UPDATE`문을 사용하지 않는다면 REPEATABLE READ 격리 수준에서도 팬텀 리드가 발생하지 않는다. 

![](https://i.imgur.com/nd63XnD.png)

실제로 위와 같이 동일한 조건에서 한 트랜잭션에 `FOR UPDATE`를 포함하여 쿼리를 날렸을 때 팬텀 리드가 발생했다.
### SERIALIZABLE
**읽기 작업도 공유 락을 획득하여 동시에 다른 트랜잭션은 해당 레코드를 변경하지 못하게하는 격리 수준**이다. 가장 엄격하며 그만큼 동시 처리 성능도 떨어진다. 앞서 살펴본 팬텀 리드 문제가 발생하지 않는다. 

![](https://i.imgur.com/394hJZr.png)

먼저 시작된 트랜잭션이 단순 `SELECT` 쿼리로 모든 `USER`를 조회한다.

![](https://i.imgur.com/XFst9NM.png)

늦게 시작된 트랜잭션에서 `USER`에 새로운 데이터를 삽입하려하면 먼저 시작된 트랜잭션의 `SELECT` 쿼리에 의해 공유락이 걸려있기 때문에 삽입이 안되고 해당 공유락이 풀릴 때까지 대기 상태에 들어간다. 팬텀 리드가 발생할 수가 없다.

## 9.1 개요

- 옵티마이저가 만드는 실행계획을 이해해야 불합리한 부분을 찾고 최적의 방법을 유도할 수 있음

### 9.1.1 쿼리 실행 절차

- 쿼리 실행 절차
    1. 사용자가 작성한 쿼리를 쪼개서 MySQL 서버가 이해 가능하도록 분리함 
        - → SQL 파서가 처리
    2. SQL 파싱 정보(파스 트리)를 확인하여 어떤 테이블, 인덱스를 어떻게 이용할지 선택 
        - → 옵티마이저가 처리
    3. 2번째 단계에서 결정된 계획으로 스토리지 엔진을 통해 데이터를 가져옴

### 9.1.2 옵티마이저의 종류

- 규칙 기반 최적화
    - 대상 테이블의 레코드 건수나 선택도를 고려하지 않고 내장된 우선순위로 실행계획을 수립함
    - 사용자 데이터는 각각 매우 다양함에도 통계 정보를 사용하지 않기에 한계가 있음
- 비용 기반 최적화
    - 쿼리 처리를 위한 여러 방법을 만들고 그 중 가장 비용이 최소인 것을 선택함. 이때, 단위 작업의 비용, 통계 정보를 활용함.

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔
    - 인덱스 사용하지 않고 처음부터 끝까지 읽는 것
    - 사용하는 경우
        - 레코드 건수가 작아서 인덱스로 읽기보다는 전체를 읽는 것이 더 빠른 경우(일반적으로 테이블이 페이지 1개인 경우)
        - 인덱스를 사용할 쿼리 조건이 없는 경우
        - 인덱스 레인지 스캔을 사용할 수 있지만 일치하는 레코드가 테이블의 20~25% 이상이어서 풀 테이블 스캔이 이득인 경우
    - 많은 디스크 읽기가 필요하므로 대부분 DBMS는 한꺼번에 여러 페이지를 읽는 기능을 내장함
    - InnoDB는 특정 테이블의 페이지가 연속적으로 읽히면 백그라운드 스레드에서 미리 버퍼풀에 가져다 둠. 이를 리드 어헤드라고 함.
        - 즉, 풀 테이블 스캔 시 첫 몇개 페이지는 포그라운드 스레드가 읽지만, 특정 시점부터는 백그라운드가 한꺼번에 4개 or 8개, 최대 64개씩 읽어서 버퍼풀에 저장해둠
    - `innodb_read-ahead_threshold` 시스템 변수로 몇개 페이지부터 백그라운드 스레드가 동작할지 정할 수 있음
    - 리드 어헤드는 풀 인덱스 스캔에도 동일하게 사용됨

### 9.2.2 병렬 처리

- 8.0 버전부터 하나의 쿼리를 여러 스레드가 나눠 처리하는 쿼리 병렬 처리가 가능해짐
    - `innodb_parallel_read_threads` 시스템 변수로 설정
- WHERE 조건 없이 테이블 전체 건수를 가져오는 쿼리만 적용
    
    ```sql
    SELECT COUNT(*) FROM salaries
    ```
    

### 9.2.3 ORDER BY 처리

- 정렬 처리 방법
    - 인덱스 이용
        - 장점
            - 이미 정렬되어 있어 매우 빠름
        - 단점
            - 쓰기 작업 시 느림
            - 인덱스를 위한 추가적 디스크 공간 필요
            - 버퍼 풀을 위한 메모리 필요
    - 쿼리 실행 시 Filesort 이용
        - 장점
            - 인덱스 사용 시의 단점이 장점이 됨
        - 단점
            - 정렬이 쿼리 실행 시 진행되므로 레코드가 많을수록 느려짐
- 모든 정렬을 인덱스를 이용하기는 어려움
    - 정렬 기준이 많아 모두 인덱스로 생성하기 어려운 경우
    - GROUP BY 나 DISTINCT 결과를 정렬해야하는 경우
    - 임시 테이블 경과를 정렬해야하는 경우
    - 랜덤 I/O로 데이터 가져오는 경우
- 실행 계획의 Extra 칼럼의 “Using filesort” 가 표시되면 인덱스를 사용하지 않은 것임

**소트 버퍼**

- 소트 버퍼는 데이터들을 정렬하기 위한 메모리 공간임
    - 데이터에 따라 가변적이나 최대 한계 있음
    - 쿼리가 끝나면 즉시 반납됨
- 소트 버퍼에 비해 데이터가 크다면, 데이터를 쪼개서 정렬하는데, 이때 임시 공간으로 디스크를 사용함. 쪼갠 데이터를 다시 합치면서 정렬하는 멀티 머지를 수행함.
- 소트 버퍼를 크게하면 해결될 것 같지만, 일정 크기 이상부터는 성능 상 큰 차이 없음. 오히려 소트 버퍼는 세션 메모리 영역이므로 세션이 많아지면 OOM 발생 가능성 커짐.

**정렬 알고리즘**

- 정렬 처리 방법
    1. 인덱스를 이용한 정렬
        
        ![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/7994f462-a16c-4b9f-a76b-b787353ab0a8)
        
        - 조건
            - 처음 읽은 테이블의 컬럼이 ORDER BY 컬럼이어야 함
            - WHERE 절에 첫번째 테이블에 대한 조건이 있다면 ORDER BY 컬럼과 같은 인덱스를 사용해야 함
            - HASH 인덱스나 전문 검색 인덱스는 사용 불가
            - 조인 시 네스티드 루프 조인이어야 함
        - ORDER BY 를 따로 써주지 않아도 정렬된 상태로 결과가 나오지만 써주는게 좋음
    2. 조인의 드라이빙 테이블만 정렬
        
        ![image](https://github.com/4k-study/book-Real-MySQL-8.0/assets/82152173/c3e2b54d-aea8-467f-8a24-f1e08012e828)
  
        - 조건
            - 처음 읽은 테이블의 컬럼이 ORDER BY 컬럼이어야 함
            - ORDER BY 컬럼으로 생성된 인덱스가 없음
    3. 임시 테이블을 이용한 정렬
        - 조건
            - ORDER BY 컬럼이 처음 읽는 테이블이 아니어서 조인 후 정렬해야 하는 경우
        - 정렬해야하는 데이터가 많으므로 가장 느림
- 정렬 처리 방법의 성능 비교
    - ORDER BY와 GROUP BY는 LIMIT을 사용해도 WHERE 조건에 해당하는 데이터를 다 가져와서 처리하기에 큰 성능 개선 없음
    - 정렬 처리 방법
        1. 스트리밍 방식
            - 조건이 일치하는 데이터를 실시간으로 클라이언트에 보내주는 방식
            - LIMIT을 통해서 전체 데이터 건수가 줄어들기에 마지막 데이터까지의 응답시간을 줄일 수 있음
        2. 버퍼링 방식
            - ORDER BY, GROUP BY 시 사용됨
            - LIMIT 시 전송되는 데이터 양은 줄일 수 있어도 처리하는 데이터 양은 줄지 않음
        - JDBC의 경우 스트리밍 방식 처리 시 자체적으로 내부 버퍼에서 모았다가 클라이언트로 반환함. 설정으로 변경 가능함.
        - 정렬 처리 방식 중 인덱스 사용 방식 외에는 버퍼링 방식임

**정렬 관련 상태 변수**

- 처리한 정렬의 상태를 `SHOW STATUS LIKE 'Sort%'` 로 알 수 있음
    - 소트 버퍼 간의 멀티머지, 정렬된 레코드 수 등을 알 수 있음

### 9.2.4 GROUP BY 처리

- HAVING 절의 조건은 인덱스를 사용할 수 없으므로 신경쓰지 않아도 됨
- GROUP BY 가 인덱스 사용하는 경우
    - 타이트 인덱스 스캔 이용
        - 처음으로 읽는 테이블의 컬럼으로 그루핑 시 그루핑하는 컬럼의 인덱스가 있다면 사용됨
    - 루스 인덱스 스캔 이용
        - 실행 계획의 Extra 컬럼에 “Using index for group-by” 표시
        - 단일 테이블 대상의 그루핑에만 사용 가능
        - 프리픽스 인덱스는 사용 불가
        - 인덱스 유니크 값이 적을수록 성능 향상

**임시 테이블을 사용하는 GROUP BY**

- 인덱스 사용 불가능 시 사용됨
- 8.0 버전 이상부터 GROUP BY 시 정렬되지 않음
- 내부적으로 GROUP BY 컬럼으로 구성된 유니크 인덱스를 가진 임시 테이블을 생성하여서 중복을 제거

### 9.2.5 DISTINCT 처리

- DINSTINCT가 집함 함수와 사용되는 경우와 아닌 경우에 따라 처리 방식이 다름

**SELECT DINSTINCT…**

- SELECT 하는 컬럼의 조합을 유니크하게 조회함. 즉, `SELECT DISTINCT first_name, last_name FROM employees` 시 (first_name, last_name) 의 유니크 조합을 조회함.

**집합 함수와 함께 사용된 DISTINCT**

- 집합 함수 내에서는 집합 함수 인자로 전달된 컬럼의 유니크 값을 가져옴

### 9.2.6 내부 임시 테이블 활용

- 스토리지 엔진으로부터 받은 데이터를 정렬하거나 그루핑할때 내부 임시 테이블 사용
    - 일반적으로 메모리에 생성했다가 커지면 디스크로 옮기는데, 예외적으로 디스크에 바로 만드는 경우도 있음

**메모리 임시 테이블과 디스크 임시 테이블**

- 8.0 버전 이상부터는 메모리는 TempTable, 디스크는 InnoDB를 사용하여 임시 테이블 저장함
    - TempTable 통해 가변 길이 타입을 지원
    - InnoDB 이용하여 트랜잭션 지원
- 8.0 버전 이상부터 메모리용 임시 테이블 기본값은 TempTable, 기본 최대 메모리 공간은 1GB 임.
    - 시스템 변수로 변경 가능함
- 최대 메모리 크기보다 커지면 디스크로 기록하는데 이때 MMAP 파일 or InnoDB 테이블로 기록 가능함
    - 시스템 변수로 설정 가능하지만 MMAP 파일이 오버헤드가 적어 기본값임
- 디스크에 임시 테이블 생성 시 파일 오픈 후 바로 삭제 처리됨
    - 즉시 삭제되지 않고 운영체제가 삭제된 파일을 참조하는 프로세스가 없어지면 자동으로 삭제함

**임시 테이블이 필요한 쿼리**

- 인덱스를 사용하지 못하고 내부에서 데이터 가공이 필요한 경우 임시 테이블이 필요함

**임시 테이블이 디스크에 생성되는 경우**

- 칼럼 길이가 512바이트보다 크거나 메모리 임시 테이블 크기가 지정 값보다 큰 경우

**임시 테이블 관련 상태 변수**

`SHOW SESSION STATUS LIKE 'Created_tmp%'` 를 통해 임시 테이블 생성 위치 알 수 있음

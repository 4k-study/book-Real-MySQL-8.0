## 개요
- 쿼리를 처리하는 방식은 다양한데, 이 방식 중 최적의 방식을 **옵티마이저가 결정**함
- 옵티마이저가 선택한 쿼리 처리 방식은 **실행 계획**을 통해 알 수 있음

### 쿼리 실행 절차
쿼리 실행은 다음 단계를 거친다.

1. 쿼리를 MySQL 서버가 이해할 수 있는 수준으로 분리(**파싱**)
   - **문법적인 오류 검증**
   - SQL 파서가 수행
2. 파싱된 트리를 통해 어떤 테이블부터 읽고 어떤 인덱스를 사용할 것인지 결정
   - 연산 단순화, 테이블 읽는 순서 결정, 인덱스 결정, 임시 테이블 생성 결정
   - **옵티마이저**가 수행
3. 데이터를 가져옴
   - 2번 과정에서 생성된 실행 계획을 통해 스토리지 엔진이 데이터 처리

### 옵티마이저 종류
- **비용 기반 최적화**
  - 여러 쿼리 중 통계 정보를 활용하여 가장 **비용이 낮은 쿼리를 계산**하여 수행하는 방법
- **규칙 기반 최적화**
  - 통계 정보를 고려하지 않고 내부적으로 정해진 우선순위에 따라 실행 계획을 수립하는 방법
  - 요즘엔 사용하지 않음

<br>

## 기본 데이터 처리
### 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔은 다음 경우에 선택될 수 있음
  - 테이블의 레코드 수가 너무 적은 경우
  - 적절한 인덱스를 사용할 수 없는 경우
  - 인덱스 스캔을 하더라도 너무 읽을 레코드 수가 많은 경우
- InnoDB는 풀 테이블, 풀 인덱스 스캔 시 리드 어헤드 작업을 통해 미리 읽을 데이터를 버퍼 풀에 가져다 두어 더 빠르게 처리됨

### 병렬 처리
- 하나의 쿼리를 여러 스레드가 병렬로 처리하도록 할 수 있음
- 병렬 처리는 조건문이 없이 테이블 전체 건수(`COUNT`)를 가져오는 쿼리만 가능

### ORDER BY 처리
정렬을 처리하는 방법은 인덱스를 사용하는 방법과 "Filesort"라는 별도의 처리를 이용하는 방법이 있음
- **인덱스를 이용하는 방법**
  - 데이터가 삽입될 때 이미 정렬되어 있어서 순서대로 읽기만 하면 됨
  - 인덱스가 가지는 단점을 모두 가짐
- **Filesort 이용**
  - 인덱스가 가지는 단점을 장점으로 가짐
  - **메모리에서 정렬**
  - 쿼리 요청 시 정렬을 수행하기 때문에 **응답 시간이 느릴 수 있음**

#### 소트 버퍼
- 소트 버퍼는 **정렬을 수행하기 위해 할당되는 별도의 메모리 공간**을 말한다.
- 정렬하려는 데이터의 양이 소트 버퍼보다 크다면 레코드를 조각으로 나눠서 소트 버퍼에서 정렬 후 **디스크에 정렬된 레코드를 쓰는 작업을 가진다.** 
  - 이러한 작업으로 인해 디스크 읽기/쓰기 연산이 많아져 성능상 안좋을 수 있다.

#### 정렬 알고리즘
- **싱글 패스 정렬 방식**
  - 정렬 키와 **레코드 전체**를 가져와서 정렬하는 방식
  - 최신 버전에서는 이 방식을 사용
  - 투 패스 방식보다 더 많은 버퍼 공간을 사용
  - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠름
- **투 패스 정렬 방식**
  - 정렬 키와 **pk**만 가져와서 정렬하는 방식
  - 정렬 후 pk에 대응되는 레코드를 **추가적으로 조회**해야 함
  - 레코드의 크기가 너무 크면 사용
  - 정렬 대상 레코드의 크기가 건수가 많은 경우 효율적 

#### 정렬 처리 방법
- **인덱스를 이용한 정렬**
  - 이미 정렬된 인덱스 값을 통해서 정렬하는 방식
  - 별도의 추가 작업은 없음 (그냥 인덱스 그대로 읽기만 하면 됨)
  - 실행 계획에 아무 표시도 안됨
  - **조건**
    - `ORDER BY`에 명시된 컬럼이 제일 먼저 읽는 테이블에 속해야 함
    - **`ORDER BY`의 순서대로 생성된 인덱스**가 있어야 함
    - `WHERE`절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건에 있다면 그 조건과 `ORDER BY`는 같은 인덱스를 사용해야 함
    - 여러 테이블이 조인되는 경우 네스티드-루프 방식의 조인에서만 사용 가능
- **조인의 드라이빙 테이블만 정렬**
  - 조인을 실행하기 전에 첫 번째 테이블만 **정렬한 뒤 조인**하는 방식
  - 실행 계획의 `Extra` 컬럼에 `Using filesort` 표기
  - **조건**
    - 드라이빙 테이블의 컬럼만으로 `ORDER BY`절을 작성해야 함
    - `ORDER BY`절의 컬럼이 인덱스에 포함되면 안됨
- **임시 테이블을 이용한 정렬**
  - 조인된 결과를 임시 테이블에 저장하고 **임시 테이블을 정렬한 뒤 반환**하는 방식
  - 실행 계획의 `Extra` 컬럼에 `Using filesort`, `Using temporary` 표기
  - **조건**
    - 인덱스를 사용하지 않고, 조인된 드라이빙 테이블만 정렬되지 않는 경우

#### 정렬 처리 방법의 성능 비교
- **스트리밍 방식**
  - 조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트에 전송하는 방식
    - 레코드를 1000만건 조회해야 해도 가장 처음 레코드는 아주 빠르게 찾을 수 있음
  - `limit`과 함께 사용되면 총 쿼리 시간이 단축됨
  - **인덱스를 이용한 정렬** 방식은 스트리밍 방식임
- **버퍼링 방식**
  - `ORDER BY`나 `GROUP BY`같은 처리는 스트리밍 방식이 불가능
    - 정렬이나 그루핑은 데이터를 찾는 건수에 따라 결과가 달라지기 때문에 꼭 다 찾은 다음 진행해야 함
  - `limit`과 함께 사용되어도 큰 성능 향상을 볼 수 없음
  - **조인의 드라이빙 테이블만 정렬**, **임시 테이블을 이용한 정렬**은 버퍼링 방식임

#### 정렬 관련 상태 변수
- 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다. 

<br>

### GROUP BY 처리
`GROUP BY`는 인덱스를 사용하여 처리할 수 있다. 인덱스를 사용하지 않는다면 임시 테이블을 사용한다.
#### 인덱스 스캔을 사용하는 GROUP BY
- 인덱스를 차례대로 읽는 방법
- 실행 계획에 별도의 표시가 없다.
- **조건**
  - 조인의 드라이빙 테이블에 속한 컬럼으로만 그루핑을 해야 함
  - 사용된 컬럼으로 인덱스가 존재해야 함

#### 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 실행 계획의 Extra 컬럼에 `Using index for group-by` 코멘트가 표시됨
- `SELECT emp_no FROM salaries WHERE name = 'Kong' GROUP BY emp_no`의 쿼리가 있고, 인덱스는 `(emp_no, name)`으로 지정되어 있을 때, `WHERE emp_no = ? AND name = 'Kong'`과 비슷하게 동작하여 인덱스 레인지 스캔을 사용할 수 있다. 
- 단일 테이블에 대해 수행되는 `GROUP BY` 처리에만 사용할 수 있음
- 인덱스의 **유니크한 값의 수가 적을수록 성능이 향상**된다.
- 별도의 임시 테이블이 필요하지 않다.

#### 임시 테이블을 사용하는 GROUP BY
- 인덱스를 전혀 사용할 수 없다면 임시 테이블을 사용함
- `GROUP BY`에 명시된 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들고 조인된 결과를 가져와서 임시테이블에서 중복을 체크하며 `INSERT`, `UPDATE`를 실행한다.
  - `name`컬럼에 대해 유니크 인덱스를 가진 임시 테이블을 만들고, 그루핑 해야하는 로우를 하나씩 가져와서 임시 테이블에서 중복을 확인하면서 집합 함수 연산을 수행한 뒤, 중복이 없다면 `INSERT`를, 있다면 집합 함수 연산을 수행한 값을 `UPDATE` 해주는 것 같다.
- 실행 계획의 Extra 컬럼에 `Using temporary`가 표시될 수 있음

<br>

### DISTINCT 처리
#### SELECT DISTINCT ...
- 내부적으로 `GROUP BY`와 동일하게 처리됨
- 참고로 `DISTINCT`는 함수가 아니기 때문에 `DISTINCT(A),B`와 `DISTINCT(A,B)`는 동일함

#### 집합 함수와 함께 사용된 DISTINCT
- `COUNT(DISTINCT salary)`처럼 집합 함수와 `DISTINCT` 키워드가 함께 사용된다면 임시 테이블을 사용할 수 있다.
  - 인덱스를 사용하지 못하는 경우
- `DISTINCT`로 **지정한 컬럼으로 구성된 유니크 인덱스를 가지는 임시 테이블을 생성**한다.
- 실행 계획에는 별도의 키워드가 표시되지 않는다.

<br>

### 내부 임시 테이블 활용
정렬하거나 그루핑을 할때 내부적으로 임시 테이블을 사용한다. 이때 이 임시 테이블을 사용자가 직접 보거나 사용할 수 없으며 쿼리 처리가 완료되면 자동으로 삭제된다.

#### 메모리 임시 테이블과 디스크 임시 테이블
MySQL 8.0 이전 버전은 임시 테이블이 메모리에 저장될 때는 MEMORY 스토리지 엔진을, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 사용했다. 하지만 8.0 이후부터는 메모리에 저장할 때 TempTable 스토리지 엔진을, 디스크에 저장할 때는 InnoDB를 사용하도록 변경되었다.

#### 임시 테이블이 필요한 쿼리 
- `ORDER BY`와 `GROUP BY`에 명시된 컬럼이 다른 쿼리
  - `Using temporary` 표시
- `ORDER BY`나 `GROUP BY`에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
  - `Using temporary` 표시
- `DISTINCT`와 `ORDER BY`가 동시에 존재하는 경우 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`이나 `UNION DISTINCT`가 사용된 쿼리
- 쿼리의 실행 계획에서 `select_type`이 `DERIVED`인 쿼리
  - 유니크 인덱스를 가진 임시 테이블은 아님 (더 빠름)


#### 임시 테이블이 디스크에 생성되는 경우
임시 테이블에 사용되는 데이터들의 크기가 큰 경우 디스크에 생성한다.

